[{"title":"CORS跨域","url":"/2024/09/29/CORS%E8%B7%A8%E5%9F%9F/","content":"\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n简单请求\n添加一个origin字段\n服务器判断origin是否被许可\n不许可不添加Access-Control-Allow-Origin，否则添加\n具体格式如下：\n\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\n\n\n非简单请求\n预检请求：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n请求头格式：options表示询问， Access-Control-Request-Method：列出使用了的方法\nOPTIONS &#x2F;cors HTTP&#x2F;1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0…\n\n\n如果否定，则服务器返回一个没有任何相关头的字段，浏览器报错\n\n解决方法\n浏览器插件\n后端配置cors\n如果需要cookie,需要前端一起配合\n\n","categories":["八股面经"],"tags":["前端","跨域"]},{"title":"CS61C P1摸鱼记","url":"/2024/09/29/CS61C%20P1%E6%91%B8%E9%B1%BC%E8%AE%B0/","content":"CS61C在20fa的P1是康威的生命游戏，涉及到了不少关于指针和内存的操作，发现自己学得太烂完全不会写，最后还是抄了PKU飞猪大佬的答案，因此特地开一篇文章记录一下相关内容和学习笔记。\nA1A1要求实现的是3个函数，&#x3D;&#x3D;readData&#x3D;&#x3D; ，&#x3D;&#x3D;writeData&#x3D;&#x3D;，和 &#x3D;&#x3D;freeImage&#x3D;&#x3D;。分别实现了\n\n将PPM文件转为IMAGE结构体\n\n将IMAGE结构体打印\n\n释放IMAGE结构体内存\n\n\n下面是代码答案，来自PKU的飞猪大佬的github。我偷了个懒，没有写NULL检查。\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;Image *readData(char *filename) &#123;\tImage *image = (Image*)malloc(sizeof(Image));\tchar format[3];\tFILE *fp = fopen(filename, &quot;r&quot;);\tint maxcolor;\tfscanf(fp, &quot;%s&quot;, format);\tfscanf(fp, &quot;%d %d&quot;, &amp;image-&gt;cols, &amp;image-&gt;rows);\tfscanf(fp, &quot;%d&quot;, &amp;maxcolor);\tint count = image-&gt;cols*image-&gt;rows;\timage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\tfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\t\treturn image;&#125;void writeData(Image *image)&#123;\tprintf(&quot;P3\\n%d %d\\n255\\n&quot;, image-&gt;cols, image-&gt;rows);\tColor** p = image-&gt;image;\tfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\t\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\t\tp++;\t\t&#125;\t\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;&#125;void freeImage(Image *image)&#123;\t\tint count = image-&gt;cols*image-&gt;rows;\tfor (int i = 0; i &lt; count; i++)\t&#123;\t\tfree(*(image-&gt;image+i));\t&#125;\t\tfree(image-&gt;image);\tfree(image);&#125;\n\n接下来我将记录一下里面关于数组和指针的一些内容。\n首先我们看看PPM文件的格式（其中一种）\n\nP3 &#x2F;&#x2F;格式\n4 5 &#x2F;&#x2F;列和行的数量\n255&#x2F;&#x2F;最大值\n0 0 0 0 0 0 0 0 0 0 0 0\n255 255 255 255 255 255 255 255 255 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n\nimage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\n\n这行代码是对IMAGE对象的image指针进行分配内存，image指针是一个双重指针，一般指向的是一个二维数组——即数组的数组。\nfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\n\n这段代码则是将像素点全部写入数组中，（image+i）代表将指针前推一个image中color的大小的值。我们可以想象指针在跳格子，每个格子都是一个color的大小。\n\n在C语言中，指针加上一个整数值可以表示地址偏移，这是因为指针在底层是以字节为单位进行偏移的。当你对指针加上一个整数值时，实际上是将指针指向的内存地址增加（或减少）相应的字节数，从而实现地址的偏移。\n例如，假设有一个指向整型数组的指针 int *ptr，如果你执行 ptr + 1，那么 ptr 将指向数组中下一个整型元素的地址，这是因为在C语言中，整型通常占据4个字节（取决于系统架构）。\n类似地，如果你有一个指向字符数组的指针 char *ptr，执行 ptr + 2 将使指针指向数组中第三个字符的地址，因为字符通常占据1个字节。\n以上内容取自gpt，以前我以为加数字是前进地址，类似于汇编。\n\n以及一个很重要的事情：**开了指针变量，一定要记得分配内存！**\nfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\tp++;&#125;\n\n这段没有什么好说的，要注意的是%3hhu代表的是宽度为3位（不够的话会自动补全）的无符号字符。\n以下是我google出来的对%c和%hhu的解释。\n\n\n\nData Type 数据类型\nFormat Specifier 格式说明符\n\n\n\nchar 字符\n%c ％C\n\n\nsigned char 有符号字符\n%c (or %hhi for numerical output)  %c（或 %hhi 用于数字输出）\n\n\nunsigned char 无符号字符\n%c (or %hhu for numerical output)  %c（或 %hhu 用于数字输出）\n\n\nA2A2需要你设计一个隐写术（Steganography）程序。用的是LSB，比较简单，这里不多赘述。比较要注意的是(variable)-&gt;B不要写成variable-&gt;B了。\nB首先我们知道，我们需要两个（至少输入的时候是）参数，filename和rule。\ny有一个方法解析rule，将每一位都走一遍与运算，将结果放到数组上。有点像桶排序？在编写逻辑时就可以用了，好像不太优雅，先试着写吧\n结束：2024.7.15 1:10最后总算是写完了，完全没有诚信可言，最后疯狂地参考PKU大佬的答案修改。\n也算是练习了一下指针和valgrind吧。想写一篇关于指针的简单博客，之后会写的。\n","categories":["随笔浅记"],"tags":["CS61C"]},{"title":"HTML笔记","url":"/2024/09/29/HTML%E7%AC%94%E8%AE%B0/","content":"如何使用a和id实现页面内跳转要在HTML中使用ID实现页面内的跳转，你可以使用`&lt;a&gt;`标签配合`href`属性来指向目标元素的ID。这里有一个简单的例子来说明如何操作：1. **定义一个带有ID的目标元素**：   ```html   &lt;div id=&quot;target&quot;&gt;     这是目标位置的内容。   &lt;/div&gt;   ```2. **创建一个链接到该目标元素的锚点**：   ```html   &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;   ```将这两个部分组合起来，你的HTML文件看起来可能是这样的：```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;页面内跳转示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;页面顶部&lt;/h1&gt;  &lt;p&gt;这是页面的起始部分。&lt;/p&gt;    &lt;!-- 创建一个链接到目标位置 --&gt;  &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;    &lt;p&gt;这里是其他内容...&lt;/p&gt;    &lt;!-- 定义带有ID的目标位置 --&gt;  &lt;div id=&quot;target&quot;&gt;    &lt;h2&gt;这是目标位置&lt;/h2&gt;    &lt;p&gt;这是目标位置的内容。&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;```当用户点击“点击跳转到目标位置”这个链接时，浏览器会滚动到ID为`target`的元素所在的位置。如果你希望在点击链接后平滑地滚动到目标位置，可以利用JavaScript或者HTML5中的`scroll-behavior: smooth;` CSS属性来实现平滑滚动效果。例如，在CSS中添加如下样式：```csshtml &#123;  scroll-behavior: smooth;&#125;```这样，当用户点击链接时，页面将会以平滑的方式滚动到目标位置。\n\nlink标签rel属性的prefetch预加载，在渲染之前提前解析好DNS拿好资源以加快加载速度\n浏览器渲染过程\n下载index.html\n\n解析\n\n下载相关资源（如css）\n\nhttps://www.51cto.com/article/771596.html\n\n\ntext-align对行内级元素进行居中处理（div这种块级元素要改成&#x3D;&#x3D;display:inline-block&#x3D;&#x3D;）\nem用作font-size时是父元素的X倍\n定位，你把一个元素一定位的话，它可能这个包含块就不再是它的父元素了\n文本居中显示line-height设置文本的行高，行距&#x3D;行高-文本&#x2F;2，可以用来设置居中\n直接子代选择器&lt;div class=&quot;home&quot;&gt;  &lt;span    &gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium    repellat quasi cumque, odit accusamus voluptates velit laudantium    facere, ratione a, molestias impedit deserunt ipsum delectus unde maxime    officia minus dolores.&lt;/span  &gt;  &lt;div class=&quot;box&quot;&gt;&lt;span&gt;草&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\n\n.home &gt; span &#123;  color: red;  padding: 20px;  margin: 20px;&#125;\n\n\n\n\n只选中了直接相连的span，如果删除&gt;换成空格则为后代选择器，两者都能选中\n选择器权重\nblock-inline\nblock块级元素可以设置宽高、inline行内级不行，宽高取决于内容的大小，但是行内替换元素可以设置，例如&#x3D;&#x3D;img&#x3D;&#x3D;、&#x3D;&#x3D;input&#x3D;&#x3D;。\n\n&#x3D;&#x3D;inline-block&#x3D;&#x3D;有两者的特性，既不占一行，又能设置宽高\n\n\n隐藏html元素的四种方法\nborder-box\nborder-box tells the browser to account for any border and padding in the values you specify for an element’s width and height. If you set an element’s width to 100 pixels, that 100 pixels will include any border or padding you added, and the content box will shrink to absorb that extra width. This typically makes it much easier to size elements. box-sizing: border-box is the default styling that browsers use for the &lt;table&gt;, &lt;select&gt;, and &lt;button&gt; elements, and for &lt;input&gt; elements whose type is radio, checkbox, reset, button, submit, color, or search.\nborder-box 告诉浏览器在您为元素的宽度和高度指定的值中考虑任何边框和填充。如果将元素的宽度设置为 100 像素，则该 100 像素将包含您添加的任何边框或填充，并且内容框将收缩以吸收该额外宽度。这通常使调整元素大小变得更加容易。box-sizing：border-box 是浏览器用于 &lt;table&gt;、&lt;select&gt; 和 &lt;button&gt; 元素的默认样式，以及类型为 radio、checkbox、reset、button、submit、color 或 search 的 &lt;input&gt; 元素的默认样式。\n\n也就是设置后元素的宽高度包括了padding和border\nmargin-top&#x2F;bottom的父元素传递\nmargin的折叠问题\n多行文字省略\n背景图适应和居中background-position:center\n\nbackground-image和img标签\n表格边框的折叠border collapse","categories":["八股面经"],"tags":["前端","HTML"]},{"title":"Rust笔记","url":"/2024/09/29/Rust%E7%AC%94%E8%AE%B0/","content":"所有权","categories":["随笔浅记"],"tags":["Rust"]},{"title":"Hello World","url":"/2024/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"x86笔记","url":"/2024/09/29/x86%E7%AC%94%E8%AE%B0/","content":"对X86寄存器、概念和常见指令做一个笔记。\n笔记来源自各大网站、博客。\n常见寄存器作用：x86-64 架构的寄存器有一些使用习惯，比如：\n\n用来传参数的寄存器：%rdi, %rsi, %rdx, %rcx, %r8, %r9\n\n保存返回值的寄存器：%rax\n\n被调用者保存状态：%rbx, %r12, %r13, %r14, %rbp, %rsp\n\n调用者保存状态：%rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11\n\n栈指针：%rsp\n\n指令指针：%rip\n\n\n函数调用约定：\n%rdi：第一个参数\n\n%rsi：第二个参数\n\n%rdx：第三个参数\n\n%rcx：第四个参数\n\n%r8：第五个参数\n\n%r9：第六个参数\n\n%rax：返回值\n\n\n数据传输指令：源目的地址:立即数,寄存器,存储器\n目的地址:寄存器,存储器\n(存储器不能到存储器)\nmov指令的五种形式：\nmovl 传送双字\nmovb 传送一个字节\nmovw 传送两个字节\n这里注意:\n&#x3D;&#x3D;movsbl&#x3D;&#x3D; &#x3D;&#x3D;movzbl&#x3D;&#x3D;指令负责拷贝一个字节,并设置目的操作数其余的位\n区别在于:\nmovsbl源操作数是单字节,move后将24位设置为源字节的最高位（在下列例子中为F）,然后拷贝到32位中。\nmovzbl 源操作数单字节,前面加24个0扩展到32位.然后拷贝到32位中.\nmov movsbl movzbl区别:\n//假设 %dh =8D,%eax=98765432 movb %dh %al      %eax=9876548D                              movsbl %dh %eax   %eax=FFFFFF8D movzbl %dh %eax   %eax=0000008D\n\n调用者保存与被调用者保存栈帧  \n想要了解栈帧的结构？我们还是先来回顾（review）以下有哪些和函数栈相关的寄存器吧。（这儿并没有包含浮点寄存器）  \n\n\n所谓调用者保存，就是可以让被调用者（自身不作为另一个调用者）随意使用，也是为了自己用到的数据不被覆盖。\n\n所谓被调用者保存，恰恰与调用者保存相反。\n\n函数调用一般参数传递（非浮点）前6个参数存于寄存器，剩下的参数按照函数定义从右向左压栈。\n\n栈指针指向函数栈栈顶。\n\n%rax 用于保存函数调用返回值。  \n  了解了这些寄存器，我们再来看看栈帧的结构\n\n\n\n就拿函数P的栈帧来说，从栈底到栈顶的方向分别存储以下内容：\n\n被保存的寄存器\n\n局部变量（sub $0x18,%rsp ）\n\n如果调用其他函数参数多于6，便有参数构造区\n\n调用其他函数时需要将返回地址压栈\n\n\n","categories":["随笔浅记"],"tags":["low-level"]},{"title":"写在之前","url":"/2024/09/29/%E5%86%99%E5%9C%A8%E4%B9%8B%E5%89%8D/","content":"一个学期文章没写多少，博客倒是换了五六次。这次大概不会再换了，大概。\n","categories":["随笔浅记"],"tags":["生活"]},{"title":"微训领航一面面经","url":"/2024/09/29/%E5%BE%AE%E8%AE%AD%E9%A2%86%E8%88%AA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/","content":"前30min\n自我介绍\n\n如何学习前端\n\n项目介绍\n\n\n八股吟唱\nvar let const 区别\n\nfor in for of区别\n\n原型和原型链\n\n闭包\n\n箭头函数\n\n跨域\n\n基本数据类型和引用类型\n\nsplice和slice\n\n知道promise吗\n\n垂直水平居中的方法\n\n宏任务与微任务\n\n知道Set吗\n\n输入域名到进入网页中间经历了什么\n\nDNS解析\n\n从服务器获取静态资源\n\nHTML和CSS渲染\n\n\n\nreact的hook你知道几个\n\n\n场景题和算法\n看代码说输出\n\nconsole.log(&quot;Start&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;Timeout&quot;);&#125;, 0);Promise.resolve().then(() =&gt; &#123;    console.log(&quot;Promise&quot;);&#125;);console.log(&quot;End&quot;);\n\nfunction MyComponent() &#123;    const [count, setCount] = useState(0);    useEffect(() =&gt; &#123;        console.log(&#x27;useEffect&#x27;);        return () =&gt; &#123;            console.log(&#x27;Cleanup&#x27;);        &#125;;    &#125;, []);    useEffect(() =&gt; &#123;        console.log(&#x27;count refresh&#x27;);    &#125;, [count]);    console.log(&#x27;Function body&#x27;);    return (        &lt;div&gt;            &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;        &lt;/div&gt;    );&#125;\n\n\n实现一个穿梭表 https://ant.design/components/transfer-cn\n\n算术表达式二叉树\n\n\ninterface RootNode &#123;    type: &quot;operator&quot; | &quot;number&quot;;    operator?: &quot;+&quot; | &quot;-&quot;    value?: number    // 如果是操作符，那么一定有左右子节点    left?: RootNode    right?: RootNode&#125;// 1 + 1 + 1const root: RootNode = &#123;    type: &quot;operator&quot;,    operator: &quot;+&quot;,    left: &#123;        type: &quot;number&quot;,        value: 1,    &#125;,    right: &#123;        type: &quot;operator&quot;,        operator: &quot;+&quot;,        left: &#123;            type: &quot;number&quot;,            value: 1        &#125;,        right: &#123;            type: &quot;number&quot;,            value: 1        &#125;    &#125;&#125;// 实现算法计算一个表达式树的值function evaluate(root: RootNode): number &#123;    &#125;// 将一个表达式树转换为表达式字符串function toExpression(root: RootNode): string &#123;    &#125;\n\n反问\n有什么建议吗？“回去多学学数据结构和算法再来吧”\n\n","categories":["八股面经"],"tags":["面经"]},{"title":"氓","url":"/2024/09/29/%E6%B0%93/","content":"氓之蚩蚩，抱布贸丝。匪来贸丝，来即我谋。送子涉淇，至于顿丘。匪我愆期，子无良媒。将子无怒，秋以为期。乘彼垝垣，以望复关。不见复关，泣涕涟涟。既见复关，载笑载言。尔卜尔筮，体无咎言。以尔车来，以我贿迁。桑之未落，其叶沃若。于嗟鸠兮，无食桑葚！于嗟女兮，无与士耽！士之耽兮，犹可说也。女之耽兮，不可说也。桑之落矣，其黄而陨。自我徂尔，三岁食贫。淇水汤汤，渐车帷裳。女也不爽，士贰其行。士也罔极，二三其德。三岁为妇，靡室劳矣。夙兴夜寐，靡有朝矣。言既遂矣，至于暴矣。兄弟不知，咥其笑矣。静言思之，躬自悼矣。及尔偕老，老使我怨。淇则有岸，隰则有泮。总角之宴，言笑晏晏。信誓旦旦，不思其反。反是不思，亦已焉哉！\n","categories":["生活杂谈"],"tags":["古诗文"]},{"title":"深夜的浅色床单与指尖流沙","url":"/2024/09/29/%E6%B7%B1%E5%A4%9C%E7%9A%84%E6%B5%85%E8%89%B2%E5%BA%8A%E5%8D%95%E4%B8%8E%E6%8C%87%E5%B0%96%E6%B5%81%E6%B2%99/","content":"\n      \n        34d180b8b826602bdbcfeb2cdb023f76d03595724d9d5478e34a06d58eaee50ff6a74fc861d3e2a6d8197d3bd73292ba18a11674cd6cb2ce8987dfcdc9c8b1ccbe7408e78c9ba3cef97d3418b52058a273ef169dbc06d2b8ae3e61e5c41c0d97f19b502adcda31405b68336926999cc29a3510852de95962384dea0382cd3daa15896413924f56d666aff62f887be1faf986a6e85c7dc02c5f5b0507ee18d64bf0bd3ca186a4bb7c76d03fb09ce2941f2fa11ebab58e012221228d1cdd7cea6ed7e46f5f12a43b9fe148c7c612e215fc16100bd5af79f75ae82dc1814fd1615d675b444fa74968bb3068a31a0bcdc98c75f5382933b07af302fda748cb1bd90cac9f93e1031a8937004e1d0079971719bb1bb97b5a5a747a39d5769e4501c123d1a253ef62bd93a5343735cbf16557c2f64223e20891432d0de861f9a56d5ef587e1a4b2fc69b508f81794469df2992448547c9226cbdfba8f9843e18050e7a4029fc4889df7a6129be05a630b4c84e91986c5710475d6f190c80698ebc1931e5ff0dccc25f95b4e47c941a601aa4efc4c7ee8b42e81dfe759544010ef0d5a4b86da139ada7eec6877403600fde9744b78cd03d9aa8c8b2c2e429af5830c240fd9ff29e6ef4940e5c4e42dea6ad36efa1111378d10b3cb93990a2cb9d091fcc30dd71cb0937c36a2890f2a9e7593997e9ff526424e68acdee7ed7730aadb7965c294e0e43b1372d28a8c95d4a4f9f9c35751de2cf62a73ecbf0e040ac0e71601b613eec1861835c5f8d733c7acfe64ccbeba3b62eec771f8eb1e81ae9a93e497595d3caff3169d082e44092f6a867bd84d73f38d9543ec118fb19e3528b96d01519908305714239327bb764d9737eba67f6ad815c85a3de1f15556b6f735236ad9bbe95bc139691079737a8f0562883920a0351457bd8e5a66da64795329fcd1e1ea4c68ab0b9886ce141354843368b55eade6f26f7fec1b2bd3d196c3f85cb482a75f53a772712d4836e7b5dac83d218a94220a146cb104cdce89ad1248b7f16156b04fbdda997e14bf044c31ec291af897fcf5d2465029376d98be74c424ec0ec4e768ad75692d736d9ec1e2d7afc1a9abc55ba787e86c28c8651a7cf819a79433746be51ebf3d43c687d247252b6d17631a8ddee4747ae682396cdccc2d038ba9d42de1b7e2cba1c4e21ee7990e930f75ccb62ee78e1dc5e18b5aea0c658ff60defef8bf3fc940ba6a539ba7d2b310c2fe26d18de8c6ddfb8855f828dffb03df2794709f88bf057226fba126658c8b3793395c2d80df3787354ea8eee4404c13d0fce7e43ae84d52d4e5f0d7975d3479a20ad868b883979296b0ca5ac8fced6969786d2053c01646ab840cdf4d2e789c68566a03d8a334d011f2f880268d0208c8cd32302c632ba21069de4c0bb1e86d90c5ccb00a43d6e7bd273ec19eec6db66210bf86f8e59f9370f052126ab9eab01bed03fe7b03d51fd641708f6e4fa466b51f3bdcae01cfa18899cc1ecac01505067148a7910efc6a524ef57cce778d7e4ffabc00f9d3084a77203611eacc296796391d9f7574d51d99c616e06dec051b9408c28575f4aaf4e674d4d9c428749abc90eea8ecf96dd45f907ff4f37414867fcd36080cd15cd0b47576e7581bbce9c8ff51b264eb92f3c30cf120d78a79cb98d51046e55a0842074bb321c2f400ac9c0b304583f05230f9bd1bdd08dc1aaa2be1c4e22d5992a38781192ca91c70fcaf3c6c44444352fb1308564f564e1df40c7190a1f9b2094b4b17e771a67bc243b1721f7a884b06798b0931b24a996ee455ddc9409afadd0174d02d688b2f1812eb2f47576dd7c6c61ea07f71da3adfcbc6c41b51005e9f3ca528bf3112651f16d30d6b2e478485dee9fde838c00a9a38e45a10263235564f9477bc560f617ea17d68588436d44a480be800c142f22582066339f0db0bfcca92fb21cbcf59ee3a664c89e66b4e82a38920a29dac2c1c9cb53f8eebd2f76a3c7bd8afb0fb0060fba917f2ee789a2e7c296fb1bd22d812fa77b61de7887a87a3a29dea7536c3baa1ae7132cccfd60f70fdece5530d4a11465c9d97ca42aae69b92f886458edc8247bc5955f20711dc69f4204cd2045f91488e77618347cb250ef8a4810b37a88d28422ed72539777af9149e3f81b18f33fb3478ac0e7b9dc688da9cf49797d1381242958ec911379ccc65969f6ed6f220f327b73d4b6edc7c4b558a43ebfeea8f0f2c2b265a81a6bfd522f85e9e62e070d12f6aefa531b447f3c59694db797358d4f5e59a3083f18fc1e5b238d6acfb1915b79fa70b702474965dee1c114f2616bd00a6f3fb657ad87344f6d62a2957e3c3fa1bce996ed8495b975f222df0f946e7e86f3f972c4afb2af8615dcd6da941be6390725267325eec21142e8c96e5782e95072efbb350afdc143413dc3d706c1cf41c0e61a3e611bf2fb9c934b42edf42b79b2df60421379d68bec1b3a5b7a87dace7c30cf6e558e9ac7fca8b17d6161f65c9127efe3457b205a185cd6535650567de3bb194fdd2eaa08467fb68cad2704b94f8f9f3a1ddbee7fdb0e2d8f3c7120081dc6795c483ef6077fd07be04060b36c6faf7c2bb17144383d2e05f5ff522d12971014b6b9cb17094560285a40d3028140ec4727331e9828b051c784a56a6ac66bf1a8b5ac69f158564fd0cb22f0cee7d3068813c0597d671d0db2e2522fce16c54559db5c1a23fb533fd3ce446c84a7d070ba393744000301d904edb21a7bc5c05da5e1cdc02538f87c501b9098956bbc1e5b47b0a3ca023bec6f3d00010fbe448d1a518f986481e6f1cd122e\n      \n      \n        \n          \n          \n            请输入未来机关授权密钥\n          \n        \n        \n      \n    \n    ","categories":["生活杂谈"],"tags":["生活","思考"]},{"title":"由61C P1开始的指针笔记","url":"/2024/09/29/%E7%94%B161C%20P1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/","content":"写61C P1的时候写出来这么一段代码\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;int count = image-&gt;cols*image-&gt;rows;image-&gt;image = (Color**)malloc(sizeof(Color*) * count);Color *evaluateOneCell(Image *image, int row, int col, uint32_t rule)&#123;\t// YOUR CODE HERE\tfor(int i = 0; i &lt; 6; i++)&#123;\t\tColor *pp =*(image-&gt;image+i);\t\tprintf(&quot;%3hhu %3hhu %3hhu&quot;,pp-&gt;R,pp-&gt;G,pp-&gt;B);\t&#125;&#125;\n\n我的问题在于不能理解\nColor *pp =*(image-&gt;image+i);\n\n这段代码表达的是什么？\n我的基础很差，很多代码细节都是仰仗PKU大佬来进行“学术不端”。但是之后还要继续挑战S081和ysyx,所以我必须要弄懂这些。\n以下内容多数来自C Pointers。\n首先我们知道，数组在内存中是连续存储的，而指针归根到底是指向地址的变量。\n指针的使用一个简单的例子int var = 10;int * ptr;ptr = &amp;var;\n\n指针解引用\n指针解引用是访问\nre pointer variable    int* ptr;    // note that data type of ptr and var must be same    ptr = &amp;var;    // assign the address of a variable to a pointer    printf(&quot;Value at ptr = %p \\n&quot;, ptr);    printf(&quot;Value at var = %d \\n&quot;, var);    printf(&quot;Value at *ptr = %d \\n&quot;, *ptr);&#125;// Driver programint main()&#123;    geeks();    return 0;&#125;\n\n输出\nValue at ptr = 0x7ffca84068dc Value at var = 10 Value at *ptr = 10 \n\n双指针在C语言中，我们可以创建指向指针的指针，以下是对原文的翻译。\n\n*pointer_name; // get the address stored in the inner level pointer获取内部指针储存的地址**pointer_name; // get the value pointed by inner level pointer获取内部指针地址\n\n\nNote: In C, we can create multi-level pointers with any number of levels such as – ***ptr3, ****ptr4, ******ptr5 and so on.\n\n\n最后写一下开头问题的答案吧这行代码Color *p =*(image-&gt;image + (newrow * image-&gt;cols + newcol));尝试做的是：\n\n计算newrow * image-&gt;cols + newcol，这给出了从图像开始到指定行和列的偏移量（假设图像数据是连续的，并且按行优先顺序排列）。\n\nimage-&gt;image + ...将image-&gt;image指针向前移动这个偏移量的位置。\n\n然后，*(...)试图解引用这个新的指针位置，但由于image-&gt;image很可能是一个指向Color类型（或类似类型，表示颜色的结构体）的指针，这里的解引用并不直接指向Color类型的值，而是指向了包含Color类型值的数组的一个Color元素。因此，理论上，直接解引用后赋值给Color*类型的指针p是合理的，但写法上有些绕。\n\n\n以上摘抄自文心一言，我个人的理解是*(...) 的括号里实际上是指向了一长串指针数组里的第一个数组索引的地址，因此当我们解引用时，我们实际得到了数组索引指向的地址，也就是元素本身的地址，最后再用Color*储存起来。\n以上就是这篇博文的大概内容了，我想再多写一些，可惜现在太晚了熬不住了，知识储备也不够，希望能在学习一些ysyx之后再来补充吧！\n其实有点伤心的，作为一个学习者，我追求的并不只是勉强看懂，而是能在需要的时候信手拈来。然而这么久我却依然没法好好的写完一个正式的project，感受coding的魅力。\n","categories":["随笔浅记"],"tags":["CS61C","指针"]}]