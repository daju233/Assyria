[{"title":"CORS跨域","url":"/2024/09/29/CORS%E8%B7%A8%E5%9F%9F/","content":"\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n简单请求\n添加一个origin字段\n服务器判断origin是否被许可\n不许可不添加Access-Control-Allow-Origin，否则添加\n具体格式如下：\n\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\n\n\n非简单请求\n预检请求：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n请求头格式：options表示询问， Access-Control-Request-Method：列出使用了的方法\nOPTIONS &#x2F;cors HTTP&#x2F;1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0…\n\n\n如果否定，则服务器返回一个没有任何相关头的字段，浏览器报错\n\n解决方法\n浏览器插件\n后端配置cors\n如果需要cookie,需要前端一起配合\n\n","categories":["八股面经"],"tags":["前端","跨域"]},{"title":"CS61C P1摸鱼记","url":"/2024/07/09/CS61C%20P1%E6%91%B8%E9%B1%BC%E8%AE%B0/","content":"CS61C在20fa的P1是康威的生命游戏，涉及到了不少关于指针和内存的操作，发现自己学得太烂完全不会写，最后还是抄了PKU飞猪大佬的答案，因此特地开一篇文章记录一下相关内容和学习笔记。\nA1A1要求实现的是3个函数，&#x3D;&#x3D;readData&#x3D;&#x3D; ，&#x3D;&#x3D;writeData&#x3D;&#x3D;，和 &#x3D;&#x3D;freeImage&#x3D;&#x3D;。分别实现了\n\n将PPM文件转为IMAGE结构体\n\n将IMAGE结构体打印\n\n释放IMAGE结构体内存\n\n\n下面是代码答案，来自PKU的飞猪大佬的github。我偷了个懒，没有写NULL检查。\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;Image *readData(char *filename) &#123;\tImage *image = (Image*)malloc(sizeof(Image));\tchar format[3];\tFILE *fp = fopen(filename, &quot;r&quot;);\tint maxcolor;\tfscanf(fp, &quot;%s&quot;, format);\tfscanf(fp, &quot;%d %d&quot;, &amp;image-&gt;cols, &amp;image-&gt;rows);\tfscanf(fp, &quot;%d&quot;, &amp;maxcolor);\tint count = image-&gt;cols*image-&gt;rows;\timage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\tfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\t\treturn image;&#125;void writeData(Image *image)&#123;\tprintf(&quot;P3\\n%d %d\\n255\\n&quot;, image-&gt;cols, image-&gt;rows);\tColor** p = image-&gt;image;\tfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\t\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\t\tp++;\t\t&#125;\t\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;&#125;void freeImage(Image *image)&#123;\t\tint count = image-&gt;cols*image-&gt;rows;\tfor (int i = 0; i &lt; count; i++)\t&#123;\t\tfree(*(image-&gt;image+i));\t&#125;\t\tfree(image-&gt;image);\tfree(image);&#125;\n\n接下来我将记录一下里面关于数组和指针的一些内容。\n首先我们看看PPM文件的格式（其中一种）\n\nP3 &#x2F;&#x2F;格式\n4 5 &#x2F;&#x2F;列和行的数量\n255&#x2F;&#x2F;最大值\n0 0 0 0 0 0 0 0 0 0 0 0\n255 255 255 255 255 255 255 255 255 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n\nimage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\n\n这行代码是对IMAGE对象的image指针进行分配内存，image指针是一个双重指针，一般指向的是一个二维数组——即数组的数组。\nfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\n\n这段代码则是将像素点全部写入数组中，（image+i）代表将指针前推一个image中color的大小的值。我们可以想象指针在跳格子，每个格子都是一个color的大小。\n\n在C语言中，指针加上一个整数值可以表示地址偏移，这是因为指针在底层是以字节为单位进行偏移的。当你对指针加上一个整数值时，实际上是将指针指向的内存地址增加（或减少）相应的字节数，从而实现地址的偏移。\n例如，假设有一个指向整型数组的指针 int *ptr，如果你执行 ptr + 1，那么 ptr 将指向数组中下一个整型元素的地址，这是因为在C语言中，整型通常占据4个字节（取决于系统架构）。\n类似地，如果你有一个指向字符数组的指针 char *ptr，执行 ptr + 2 将使指针指向数组中第三个字符的地址，因为字符通常占据1个字节。\n以上内容取自gpt，以前我以为加数字是前进地址，类似于汇编。\n\n以及一个很重要的事情：**开了指针变量，一定要记得分配内存！**\nfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\tp++;&#125;\n\n这段没有什么好说的，要注意的是%3hhu代表的是宽度为3位（不够的话会自动补全）的无符号字符。\n以下是我google出来的对%c和%hhu的解释。\n\n\n\nData Type 数据类型\nFormat Specifier 格式说明符\n\n\n\nchar 字符\n%c ％C\n\n\nsigned char 有符号字符\n%c (or %hhi for numerical output)  %c（或 %hhi 用于数字输出）\n\n\nunsigned char 无符号字符\n%c (or %hhu for numerical output)  %c（或 %hhu 用于数字输出）\n\n\nA2A2需要你设计一个隐写术（Steganography）程序。用的是LSB，比较简单，这里不多赘述。比较要注意的是(variable)-&gt;B不要写成variable-&gt;B了。\nB首先我们知道，我们需要两个（至少输入的时候是）参数，filename和rule。\ny有一个方法解析rule，将每一位都走一遍与运算，将结果放到数组上。有点像桶排序？在编写逻辑时就可以用了，好像不太优雅，先试着写吧\n结束：2024.7.15 1:10最后总算是写完了，完全没有诚信可言，最后疯狂地参考PKU大佬的答案修改。\n也算是练习了一下指针和valgrind吧。想写一篇关于指针的简单博客，之后会写的。\n","categories":["随笔浅记"],"tags":["CS61C"]},{"title":"HTML笔记","url":"/2024/07/30/HTML%E7%AC%94%E8%AE%B0/","content":"如何使用a和id实现页面内跳转要在HTML中使用ID实现页面内的跳转，你可以使用`&lt;a&gt;`标签配合`href`属性来指向目标元素的ID。这里有一个简单的例子来说明如何操作：1. **定义一个带有ID的目标元素**：   ```html   &lt;div id=&quot;target&quot;&gt;     这是目标位置的内容。   &lt;/div&gt;   ```2. **创建一个链接到该目标元素的锚点**：   ```html   &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;   ```将这两个部分组合起来，你的HTML文件看起来可能是这样的：```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;页面内跳转示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;页面顶部&lt;/h1&gt;  &lt;p&gt;这是页面的起始部分。&lt;/p&gt;    &lt;!-- 创建一个链接到目标位置 --&gt;  &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;    &lt;p&gt;这里是其他内容...&lt;/p&gt;    &lt;!-- 定义带有ID的目标位置 --&gt;  &lt;div id=&quot;target&quot;&gt;    &lt;h2&gt;这是目标位置&lt;/h2&gt;    &lt;p&gt;这是目标位置的内容。&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;```当用户点击“点击跳转到目标位置”这个链接时，浏览器会滚动到ID为`target`的元素所在的位置。如果你希望在点击链接后平滑地滚动到目标位置，可以利用JavaScript或者HTML5中的`scroll-behavior: smooth;` CSS属性来实现平滑滚动效果。例如，在CSS中添加如下样式：```csshtml &#123;  scroll-behavior: smooth;&#125;```这样，当用户点击链接时，页面将会以平滑的方式滚动到目标位置。\n\nlink标签rel属性的prefetch预加载，在渲染之前提前解析好DNS拿好资源以加快加载速度\n浏览器渲染过程\n下载index.html\n\n解析\n\n下载相关资源（如css）\n\nhttps://www.51cto.com/article/771596.html\n\n\ntext-align对行内级元素进行居中处理（div这种块级元素要改成&#x3D;&#x3D;display:inline-block&#x3D;&#x3D;）\nem用作font-size时是父元素的X倍\n定位，你把一个元素一定位的话，它可能这个包含块就不再是它的父元素了\n文本居中显示line-height设置文本的行高，行距&#x3D;行高-文本&#x2F;2，可以用来设置居中\n直接子代选择器&lt;div class=&quot;home&quot;&gt;  &lt;span    &gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium    repellat quasi cumque, odit accusamus voluptates velit laudantium    facere, ratione a, molestias impedit deserunt ipsum delectus unde maxime    officia minus dolores.&lt;/span  &gt;  &lt;div class=&quot;box&quot;&gt;&lt;span&gt;草&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\n\n.home &gt; span &#123;  color: red;  padding: 20px;  margin: 20px;&#125;\n\n\n\n\n只选中了直接相连的span，如果删除&gt;换成空格则为后代选择器，两者都能选中\n选择器权重\nblock-inline\nblock块级元素可以设置宽高、inline行内级不行，宽高取决于内容的大小，但是行内替换元素可以设置，例如&#x3D;&#x3D;img&#x3D;&#x3D;、&#x3D;&#x3D;input&#x3D;&#x3D;。\n\n&#x3D;&#x3D;inline-block&#x3D;&#x3D;有两者的特性，既不占一行，又能设置宽高\n\n\n隐藏html元素的四种方法\nborder-box\nborder-box tells the browser to account for any border and padding in the values you specify for an element’s width and height. If you set an element’s width to 100 pixels, that 100 pixels will include any border or padding you added, and the content box will shrink to absorb that extra width. This typically makes it much easier to size elements. box-sizing: border-box is the default styling that browsers use for the &lt;table&gt;, &lt;select&gt;, and &lt;button&gt; elements, and for &lt;input&gt; elements whose type is radio, checkbox, reset, button, submit, color, or search.\nborder-box 告诉浏览器在您为元素的宽度和高度指定的值中考虑任何边框和填充。如果将元素的宽度设置为 100 像素，则该 100 像素将包含您添加的任何边框或填充，并且内容框将收缩以吸收该额外宽度。这通常使调整元素大小变得更加容易。box-sizing：border-box 是浏览器用于 &lt;table&gt;、&lt;select&gt; 和 &lt;button&gt; 元素的默认样式，以及类型为 radio、checkbox、reset、button、submit、color 或 search 的 &lt;input&gt; 元素的默认样式。\n\n也就是设置后元素的宽高度包括了padding和border\nmargin-top&#x2F;bottom的父元素传递\nmargin的折叠问题\n多行文字省略\n背景图适应和居中background-position:center\n\nbackground-image和img标签\n表格边框的折叠border collapse","categories":["八股面经"],"tags":["前端","HTML"]},{"title":"JS基础引用类型","url":"/2024/05/28/JS%E5%9F%BA%E7%A1%80%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","content":"\nJS的基础类型有Number,String,Boolean,Undefined,Null,Symbol,Bigint，这些类型的变量储存在栈上（速度仅次于寄存器，但生命周期比较严格），引用类型有对象字面量、数组、函数等，储存在堆上。\n当我们写出如上图age&#x3D;oldage的语句时，此时age与oldage实际指向同一个基础类型变量地址的值。然而当我们改变age的值时，我们会在一个新的地址创建变量并指向它。\n然而当我们使用引用变量时，我们首先在堆上的D30F地址处创建了该对象，并在栈上创建了一个新的变量，变量的值指向堆上的地址D30F。当我们写出friend&#x3D;me时，我们实际是将friend指向了栈上0003地址处的D30F对象。\n这也是为什么对象是const常量但我们依然能改变其中属性的原因。因为我们实际并没有改变栈上变量指向的地址。\n","categories":["随笔浅记"],"tags":["JavaScript"]},{"title":"Rust笔记","url":"/2024/09/29/Rust%20Enum%E7%B1%BB%E5%9E%8B/","content":"  enum Message &#123;// TODO: implement the message variant types based on their usage belowChangeColor(u8,u8,u8),Echo(String),Move(Point),Quit&#125;  struct Point &#123;x: u8,y: u8,&#125;  struct State &#123;color: (u8, u8, u8),position: Point,quit: bool,message: String&#125;  impl State &#123;fn change_color(&amp;mut self, color: (u8, u8, u8)) &#123;self.color = color;&#125;  fn quit(&amp;mut self) &#123;self.quit = true;&#125;  fn echo(&amp;mut self, s: String) &#123; self.message = s &#125;  fn move_position(&amp;mut self, p: Point) &#123;self.position = p;&#125;  fn process(&amp;mut self, message: Message) &#123;// TODO: create a match expression to process the different message// variants// Remember: When passing a tuple as a function argument, you&#x27;ll need// extra parentheses: fn function((t, u, p, l, e))match message&#123;Message::ChangeColor(red,green,blue)=&gt;&#123;self.change_color((red,green,blue))&#125;,Message::Move(state)=&gt;&#123;self.move_position(state)&#125;,Message::Echo(s)=&gt;&#123;self.echo(s)&#125;Message::Quit=&gt;&#123;self.quit()&#125;  &#125;&#125;&#125;  #[cfg(test)]mod tests &#123;use super::*;  #[test]fn test_match_message_call() &#123;let mut state = State &#123;quit: false,position: Point &#123; x: 0, y: 0 &#125;,color: (0, 0, 0),message: &quot;hello world&quot;.to_string(),&#125;;state.process(Message::ChangeColor(255, 0, 255));state.process(Message::Echo(String::from(&quot;hello world&quot;)));state.process(Message::Move(Point &#123; x: 10, y: 15 &#125;));state.process(Message::Quit);  assert_eq!(state.color, (255, 0, 255));assert_eq!(state.position.x, 10);assert_eq!(state.position.y, 15);assert_eq!(state.quit, true);assert_eq!(state.message, &quot;hello world&quot;);&#125;&#125;","categories":["随笔浅记"],"tags":["Rust"]},{"title":"Rust-rustlings-error6错误处理","url":"/2024/10/09/Rust-rustlings-error6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","content":"关键代码// This is a custom error type that we will be using in `parse_pos_nonzero()`.#[derive(PartialEq, Debug)]enum ParsePosNonzeroError &#123;    Creation(CreationError),    ParseInt(ParseIntError),&#125;impl ParsePosNonzeroError &#123;    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError &#123;        ParsePosNonzeroError::Creation(err)    &#125;    fn from_parseint(err:ParseIntError)-&gt; ParsePosNonzeroError &#123;        ParsePosNonzeroError::ParseInt(err)    &#125;    // TODO: add another error conversion function here.    // fn from_parseint...&#125;fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    // TODO: change this to return an appropriate error instead of panicking    // when `parse()` returns an error.    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;    /*    这行代码的意思是，如果 s.parse() 解析成功，则将解析后的整数值赋值给 x；    如果解析失败，? 操作符会立即返回并将 ParseIntError 转换为 ParsePosNonzeroError::ParseInt 错误    并将其作为 parse_pos_nonzero 函数的返回结果。    在 Rust 中，? 操作符用于简化错误处理的过程。    它只能在返回 Result 或 Option 的函数中使用。当使用 ? 操作符时，编译器会自动为你处理错误的传播。     */    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)&#125;\n\n完整代码// errors6.rs//// Using catch-all error types like `Box&lt;dyn error::Error&gt;` isn&#x27;t recommended// for library code, where callers might want to make decisions based on the// error content, instead of printing it out or propagating it further. Here, we// define a custom error type to make it possible for callers to decide what to// do next when our function returns an error.// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a// hint.use std::num::ParseIntError;// This is a custom error type that we will be using in `parse_pos_nonzero()`.#[derive(PartialEq, Debug)]enum ParsePosNonzeroError &#123;    Creation(CreationError),    ParseInt(ParseIntError),&#125;impl ParsePosNonzeroError &#123;    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError &#123;        ParsePosNonzeroError::Creation(err)    &#125;    fn from_parseint(err:ParseIntError)-&gt; ParsePosNonzeroError &#123;        ParsePosNonzeroError::ParseInt(err)    &#125;    // TODO: add another error conversion function here.    // fn from_parseint...&#125;fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    // TODO: change this to return an appropriate error instead of panicking    // when `parse()` returns an error.    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;    /*    这行代码的意思是，如果 s.parse() 解析成功，则将解析后的整数值赋值给 x；    如果解析失败，? 操作符会立即返回并将 ParseIntError 转换为 ParsePosNonzeroError::ParseInt 错误    并将其作为 parse_pos_nonzero 函数的返回结果。    在 Rust 中，? 操作符用于简化错误处理的过程。    它只能在返回 Result 或 Option 的函数中使用。当使用 ? 操作符时，编译器会自动为你处理错误的传播。     */    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)&#125;// Don&#x27;t change anything below this line.#[derive(PartialEq, Debug)]struct PositiveNonzeroInteger(u64);#[derive(PartialEq, Debug)]enum CreationError &#123;    Negative,    Zero,&#125;impl PositiveNonzeroInteger &#123;    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; &#123;        match value &#123;            x if x &lt; 0 =&gt; Err(CreationError::Negative),            x if x == 0 =&gt; Err(CreationError::Zero),            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),        &#125;    &#125;&#125;#[cfg(test)]mod test &#123;    use super::*;    #[test]    fn test_parse_error() &#123;        // We can&#x27;t construct a ParseIntError, so we have to pattern match.        assert!(matches!(            parse_pos_nonzero(&quot;not a number&quot;),            Err(ParsePosNonzeroError::ParseInt(_))        ));    &#125;    #[test]    fn test_negative() &#123;        assert_eq!(            parse_pos_nonzero(&quot;-555&quot;),            Err(ParsePosNonzeroError::Creation(CreationError::Negative))        );    &#125;    #[test]    fn test_zero() &#123;        assert_eq!(            parse_pos_nonzero(&quot;0&quot;),            Err(ParsePosNonzeroError::Creation(CreationError::Zero))        );    &#125;    #[test]    fn test_positive() &#123;        let x = PositiveNonzeroInteger::new(42);        assert!(x.is_ok());        assert_eq!(parse_pos_nonzero(&quot;42&quot;), Ok(x.unwrap()));    &#125;&#125;","categories":["随笔浅记"],"tags":["Rust","Rustlings"]},{"title":"Rust那些小细节","url":"/2024/10/09/Rust%E9%82%A3%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82/","content":"\n记录rust那些令我抓狂的小细节\n\n读取 vector 的元素有两种方法引用 vector 中储存的值：通过索引或使用 get 方法。在接下来的示例中，为了更加清楚的说明，我们已经标注了这些函数返回的值的类型。\n示例 8-4 展示了访问 vector 中一个值的两种方式，索引语法或者 get 方法：\nlet v = vec![1, 2, 3, 4, 5];let third: &amp;i32 = &amp;v[2];println!(&quot;The third element is &#123;third&#125;&quot;);let third: Option&lt;&amp;i32&gt; = v.get(2); match third &#123;   Some(third) =&gt; println!(&quot;The third element is &#123;third&#125;&quot;),   None =&gt; println!(&quot;There is no third element.&quot;),&#125;\n列表 8-4：使用索引语法或 get 方法来访问 vector 中的项\n这里有几个细节需要注意。我们使用索引值 2 来获取第三个元素，因为索引是从数字 0 开始的。使用 &amp; 和 [] 会得到一个索引位置元素的引用。当使用索引作为参数调用 get 方法时，会得到一个可以用于 match 的 Option&lt;&amp;T&gt;。\nRust 提供了两种引用元素的方法的原因是当尝试使用现有元素范围之外的索引值时可以选择让程序如何运行。举个例子，让我们看看使用这个技术，尝试在当有一个 5 个元素的 vector 接着访问索引 100 位置的元素会发生什么，如示例 8-5 所示：\n这段代码会 Panic！\nlet v = vec![1, 2, 3, 4, 5];let does_not_exist = &amp;v[100];let does_not_exist = v.get(100);\n示例 8-5：尝试访问一个包含 5 个元素的 vector 的索引 100 处的元素\n当运行这段代码，你会发现对于第一个 [] 方法，当引用一个不存在的元素时 Rust 会造成 panic。这个方法更适合当程序认为尝试访问超过 vector 结尾的元素是一个严重错误的情况，这时应该使程序崩溃。\n当 get 方法被传递了一个数组外的索引时，它不会 panic 而是返回 None。当偶尔出现超过 vector 范围的访问属于正常情况的时候可以考虑使用它。接着你的代码可以有处理 Some(&amp;element) 或 None 的逻辑，如第六章讨论的那样。例如，索引可能来源于用户输入的数字。如果它们不慎输入了一个过大的数字那么程序就会得到 None 值，你可以告诉用户当前 vector 元素的数量并再请求它们输入一个有效的值。这就比因为输入错误而使程序崩溃要友好的多！\n"},{"title":"bomblab小记","url":"/2024/06/20/bomblab%E5%B0%8F%E8%AE%B0/","content":"被期末考硬控了很久，终于稍微有点空了，打算先试着把CSAPP写完。虽然写得很混子，但是暂时先记着，总比没有来得好。\n版本：XieGuochao&#x2F;csapp: The docker source and materials for CS:APP labs (github.com)\nPhase4这里充当笔记记录一下phase4的分析过程，phase1-3比较简单，之后也许会补上，也许不会。\n以下是对phase4汇编代码的一些注释，本来写了一大段结果忘记保存，破防之后决定参考一下别人的博客好了。\nDump of assembler code for function phase_4:=&gt; 0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp//栈空间扩展24   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx//第二个参数   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx//第一个参数   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi//   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;//参数数量不等于2，爆炸   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;//param1小于等于14，否则爆炸   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi//为func4准备参数（d1,0,14）   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax//测试返回值是否为0   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)//d2为0   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp   0x0000000000401061 &lt;+85&gt;:    retq   \n\nDump of assembler code for function func4://edi=x,esi=y,edx=14=&gt; 0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax //eax=14   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax //14-0   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx //ecx=14   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx//14逻辑右移31位（为0）   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax//14+0   0x0000000000400fdd &lt;+15&gt;:    sar    %eax//14/2（算术右移一位）   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx//???   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx    0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;//x&lt;=7则跳转至+43，否则进入递归   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;//大于等于7则函数返回0   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp   0x000000000040100b &lt;+61&gt;:    retq   \n\nPhase5Dump of assembler code for function phase_5:=&gt; 0x0000000000401062 &lt;+0&gt;:     push   %rbx   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx   0x00000000004010f3 &lt;+145&gt;:   retq   End of assembler dump.\n\nPhase6Dump of assembler code for function phase_6:   0x00000000004010f4 &lt;+0&gt;:     push   %r14   0x00000000004010f6 &lt;+2&gt;:     push   %r13   0x00000000004010f8 &lt;+4&gt;:     push   %r12   0x00000000004010fa &lt;+6&gt;:     push   %rbp   0x00000000004010fb &lt;+7&gt;:     push   %rbx   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp//r14   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13    0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14 //rsp-&gt;r14   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d //r12d-&gt;0    0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp //r13-&gt;rbp   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax//eax&lt;5 //参数小于6   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d //r12d=1//循环开始   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d//大循环 循环六次   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx //ebx=1   ; 0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax //rax=1 //循环开始   ; 0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax //换下一个参数   ; 0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)   ; 0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;   ; 0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;   ; 0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx//ebx+=1   ; 0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx   ; 0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;//小循环 循环五次 比较每个数是否相等   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax//r14-&gt;rax   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx//7-a[i]   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax//下一个参数   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax //rsi=?   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;//循环结束   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax//rdx+16取出链表下一个数的地址   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)//   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;//旧的大于新的   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp   0x00000000004011fb &lt;+263&gt;:   pop    %rbx   0x00000000004011fc &lt;+264&gt;:   pop    %rbp   0x00000000004011fd &lt;+265&gt;:   pop    %r12   0x00000000004011ff &lt;+267&gt;:   pop    %r13   0x0000000000401201 &lt;+269&gt;:   pop    %r14   0x0000000000401203 &lt;+271&gt;:   retq   ","categories":["随笔浅记"],"tags":["CSAPP"]},{"title":"fetch、promise和浏览器线程","url":"/2024/10/04/fetch%E3%80%81promise%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B/","content":"TODO","categories":["随笔浅记"],"tags":["前端"]},{"title":"Hello World","url":"/2024/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"hot100刷题记录","url":"/2024/10/05/hot100%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"二分class Solution &#123;public:int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;int n = nums.size();int left = 0;int right = n;int mid = 0;while(left&lt;right)&#123;\tmid = left+(right-left)&gt;&gt;1;\tif(target&lt;nums[mid])&#123;\t\tright = mid;\t&#125;else if(target&gt;nums[mid])&#123;\t\tleft = mid+1;\t&#125;else return mid;&#125;return right;&#125;&#125;;\n评价：板子，多背。\n74. 搜索二维矩阵class Solution &#123;public:bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;int l = 0;int r = matrix.size();int res =0;while(l&lt;r)&#123;\tint mid = l+((r-l)&gt;&gt;1);\tif(target&gt;matrix[mid][0])&#123;\t\tl=mid+1;\t&#125;else if(target&lt;matrix[mid][0])&#123;\t\tr=mid;\t&#125;else return true;&#125;res = l-1;if (res &lt; 0 || res &gt;= matrix.size()) &#123;\treturn false;&#125;int l2=0;int r2 =matrix[res].size();while(l2&lt;r2)&#123;\tint mid2 = l2+((r2-l2)&gt;&gt;1);if(target&gt;matrix[res][mid2])&#123;\tl2=mid2+1;&#125;else if(target&lt;matrix[res][mid2])&#123;\tr2=mid2;&#125;else return true;&#125;return false;&#125;&#125;;\n评价：太几把猪鼻了，在res&lt;0里纠结了很久，以及，l是第一个大于target的行索引。\n\n循环结束时，l 和 r 会相等，且 l 是第一个大于或等于 target 的行索引。\n因此，res = l - 1 是最后一个小于 target 的行索引。\n\n34. 在排序数组中查找元素的第一个和最后一个位置class Solution &#123;        int lower_bound(vector&lt;int&gt; &amp;nums,int target)&#123;            int left = -1,right=nums.size();            while(left+1&lt;right)&#123;                int mid = left+(right-left)/2;                if(nums[mid]&lt;target)&#123;                    left = mid;                &#125;else&#123;                    right = mid;                &#125;            &#125;            return right;        &#125;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int start = lower_bound(nums,target);        if(start==nums.size()||nums[start]!=target)return &#123;-1,-1&#125;;        int end = lower_bound(nums,target+1)-1;        return &#123;start,end&#125;;    &#125;&#125;;\n评价：用0x3f的开区间写法，left right是循环不变量，left必定指向小于target的数，而right必定指向大于等于target的数\n二叉树94. 二叉树的中序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    void inorder(TreeNode* root,vector&lt;int&gt;&amp; res)&#123;        if(!root)&#123;            return;        &#125;        inorder(root-&gt;left,res);        res.push_back(root-&gt;val);        inorder(root-&gt;right,res);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    &#125;&#125;;\n太史公曰：\n\n中序遍历的递归实现这道题不难写，但我还是想回到中序遍历的定义。\n\nconst inorderTraversal = (root) =&gt; &#123;const res = [];const inorder = (root) =&gt; &#123;\t if (root == null) &#123;\t\t return;\t &#125;\t inorder(root.left); // 先递归左子树\t res.push(root.val); // 将当前节点值推入res\t inorder(root.right); // 再递归右子树 &#125;;     inorder(root);     return res; &#125;;\n\n我之前提过，我们不能含糊地记说：“中序遍历是先访问左子树，再访问根节点，再访问右子树”。\n这么描述是不准确的，容易产生误导。\n事实上，无论是前、中、后序遍历，都是先访问根节点，再访问它的左子树，再访问它的右子树。\n那它们之间的区别在哪里？\n比如中序遍历，它是将 do something with root（处理当前节点）放在了访问完它的左子树之后。比方说，Printf 一下节点值，就会产生「左 根 右」的打印顺序。\n\n\n前、中、后序遍历都是基于DFS，节点的访问顺序如上图所示，每个节点有三个不同的驻留阶段，即每个节点会被经过三次：\n在递归它的左子树之前。在递归完它的左子树之后，在递归它的右子树之前。在递归完它的右子树之后。我们将 do something with root 这个操作，放在这三个时间点之一，就分别对应：前、中、后序遍历。\n所以，它们的唯一区别是：在什么时间点去处理节点，去拿他做文章。\n所以『中序遍历』的模板如下：\n\nnorder (root) &#123;    call inorder(root.left)     access the content of root   call inorder(root.right) &#125;\n\n中序遍历的迭代实现搞清楚概念后，怎么用栈去模拟递归遍历，并且是中序遍历呢？\n递归遍历一棵树，如下图，会先递归节点A，再递归B，再递归D，一个个压入递归栈。\n\n\n即，先不断地将左节点压入栈，我们写出这部分代码：\nwhile (root) {    stack.push(root);    root &#x3D; root.left;}DFS的访问顺序是：根节点、左子树、右子树，现在要访问已入栈的节点的右子树了。\n并且是先访问『位于树的底部的』即『位于栈的顶部的』节点的右子树。\n于是，让栈顶节点出栈，出栈的同时，把它的右子节点压入栈，相当于递归右子节点。\n因为是中序遍历，在栈顶节点的右子节点压栈之前，要处理出栈节点的节点值，将它输出。\n新入栈的右子节点（右子树），就是在递归它。和节点A、B、D的压栈一样，它们都是子树。\n不同的子树要做同样的事情，一样要先将它的左子节点不断压栈，然后再出栈，带出右子节点入栈。\n\n\n即栈顶出栈的过程，也要包含下面代码，可见下面代码重复了两次：\nwhile (root) {    stack.push(root);    root &#x3D; root.left;}其实这两个 while 循环，分别对应了下面的两次 inorder 调用，就是递归压栈：\ninorder(root.left);res.push(root.val);inorder(root.right);迭代实现 代码jsgoconst inorderTraversal &#x3D; (root) &#x3D;&gt; {  const res &#x3D; [];  const stack &#x3D; [];\n  while (root) {        &#x2F;&#x2F; 能压栈的左子节点都压进来    stack.push(root);    root &#x3D; root.left;  }  while (stack.length) {    let node &#x3D; stack.pop(); &#x2F;&#x2F; 栈顶的节点出栈    res.push(node.val);     &#x2F;&#x2F; 在压入右子树之前，处理它的数值部分（因为中序遍历）    node &#x3D; node.right;      &#x2F;&#x2F; 获取它的右子树    while (node) {          &#x2F;&#x2F; 右子树存在，执行while循环      stack.push(node);     &#x2F;&#x2F; 压入当前root      node &#x3D; node.left;     &#x2F;&#x2F; 不断压入左子节点    }  }  return res;};我把递归写法再次拿出来，供大家对比，感受一下二者的区别和相同点。\n\nconst inorderTraversal = (root) =&gt; &#123;  const res = []; const inorder = (root) =&gt; &#123;    if (root == null) &#123;      return;    &#125;    inorder(root.left);    res.push(root.val);    inorder(root.right);  &#125;;  inorder(root);  return res;&#125;;\n\n\n全流程大致图示后记暂且分析中序遍历，前序遍历和后序遍历的迭代版分析也许会补充上来，大家可以动手试试。\n明确这三种遍历都是基于DFS递归，清楚概念，再明白递归其实是压栈出栈的操作，比照着，用一个栈，去模拟递归栈，用迭代，去模拟递归的逻辑，就不难写出迭代法的代码。\n\n回溯46. 全排列class Solution &#123;private:vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;    void dfs(vector&lt;int&gt; nums,int x,vector&lt;bool&gt; used)&#123;        if(x==nums.size())&#123;            res.push_back(path);            return;        &#125;        for(int i = 0;i&lt;nums.size();i++)&#123;            if(used[i])continue;            used[i]=true;            path.push_back(nums[i]);            dfs(nums,x+1,used);            used[i]=false;            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        vector&lt;bool&gt; used(n);        dfs(nums,0,used);        return res;    &#125;&#125;;\n评价：循环该从0开始，每次都是遍历整个数组找没用过的数\n78. 子集class Solution &#123;private:vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;    void dfs(vector&lt;int&gt; nums,int x)&#123;        res.push_back(path);        for(int i = x;i&lt;nums.size();i++)&#123;            path.push_back(nums[i]);            dfs(nums,i+1);            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        dfs(nums,0);        return res;    &#125;&#125;;\n评价：dfs参数是i+1,避开已经看过的数\n前缀和与子串303. 区域和检索 - 数组不可变class NumArray &#123;    public:vector&lt;int&gt; s;    NumArray(vector&lt;int&gt;&amp; nums) &#123;        s.resize(nums.size()+1);        s[0]=0;        for(int i =0;i&lt;nums.size();i++)&#123;            s[i+1]=s[i]+nums[i];        &#125;    &#125;        int sumRange(int left, int right) &#123;        return s[right+1]-s[left];    &#125;&#125;;/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(left,right); */\n\n560. 和为 K 的子数组class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; s(nums.size()+1);        unordered_map&lt;int,int&gt; cnt;        s[0]=0;        for(int i=0;i&lt;nums.size();i++)&#123;            s[i+1]=s[i]+nums[i];            cnt[s[i]]++;        &#125;        int ans = 0;        for(int i =0;i&lt;s.size();i++)&#123;            ans += cnt[s[i]-k];        &#125;        return ans;            &#125;&#125;;//这是错的 错误关键在于 遍历前缀和时应该在遍历之后在哈希表里++，下面是自己的写法和0x3f写法//自己的正确写法class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; s(nums.size()+1);        unordered_map&lt;int,int&gt; cnt;        s[0]=0;        for(int i=0;i&lt;nums.size();i++)&#123;            s[i+1]=s[i]+nums[i];        &#125;        int ans = 0;        for(int i =0;i&lt;s.size();i++)&#123;            ans += cnt[s[i]-k];            cnt[s[i]]++;        &#125;        return ans;            &#125;&#125;;//0x3f写法class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; s(nums.size()+1);        unordered_map&lt;int,int&gt; cnt;        int ans = 0;        for(int i=0;i&lt;nums.size();i++)&#123;            s[i+1]=s[i]+nums[i];        &#125;        for (int i=0;i&lt;s.size();i++) &#123;            // 注意不要直接 += cnt[s[i]-k]，如果 s[i]-k 不存在，会插入 s[i]-k            ans += cnt.contains(s[i] - k) ? cnt[s[i] - k] : 0;            cnt[s[i]]++;        &#125;        return ans;            &#125;&#125;;//1 2 3//0 1 3 6//0:1 1:1 3:1 3-3=0:1 3:1 6:1\n\n239. 滑动窗口最大值class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        // for(int r =0;r&lt;nums.size();l++)&#123;        //     r=l+k;        //     int a = l;        //     int temp = -100000;        //     while(a&lt;r)&#123;        //         temp = max(nums[a],temp);        //         a++;        //     &#125;        //     res.push_back(temp);        // &#125;        // return res;        vector&lt;int&gt; res;        int n = nums.size();        priority_queue&lt;pair&lt;int,int&gt;&gt; p;        for(int r = 0;r&lt;nums.size();r++)&#123;            p.push(&#123;nums[r],r&#125;);            if(p.size()&gt;=k)&#123;                while(p.top().second&lt;=r-k)&#123;                    p.pop();                &#125;                res.push_back(p.top().first);            &#125;        &#125;        return res;    &#125;&#125;;\n\n","categories":["八股面经"],"tags":["算法"]},{"title":"x86笔记","url":"/2024/06/21/x86%E7%AC%94%E8%AE%B0/","content":"对X86寄存器、概念和常见指令做一个笔记。\n笔记来源自各大网站、博客。\n常见寄存器作用：x86-64 架构的寄存器有一些使用习惯，比如：\n\n用来传参数的寄存器：%rdi, %rsi, %rdx, %rcx, %r8, %r9\n\n保存返回值的寄存器：%rax\n\n被调用者保存状态：%rbx, %r12, %r13, %r14, %rbp, %rsp\n\n调用者保存状态：%rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11\n\n栈指针：%rsp\n\n指令指针：%rip\n\n\n函数调用约定：\n%rdi：第一个参数\n\n%rsi：第二个参数\n\n%rdx：第三个参数\n\n%rcx：第四个参数\n\n%r8：第五个参数\n\n%r9：第六个参数\n\n%rax：返回值\n\n\n数据传输指令：源目的地址:立即数,寄存器,存储器\n目的地址:寄存器,存储器\n(存储器不能到存储器)\nmov指令的五种形式：\nmovl 传送双字\nmovb 传送一个字节\nmovw 传送两个字节\n这里注意:\n&#x3D;&#x3D;movsbl&#x3D;&#x3D; &#x3D;&#x3D;movzbl&#x3D;&#x3D;指令负责拷贝一个字节,并设置目的操作数其余的位\n区别在于:\nmovsbl源操作数是单字节,move后将24位设置为源字节的最高位（在下列例子中为F）,然后拷贝到32位中。\nmovzbl 源操作数单字节,前面加24个0扩展到32位.然后拷贝到32位中.\nmov movsbl movzbl区别:\n//假设 %dh =8D,%eax=98765432 movb %dh %al      %eax=9876548D                              movsbl %dh %eax   %eax=FFFFFF8D movzbl %dh %eax   %eax=0000008D\n\n调用者保存与被调用者保存栈帧  \n想要了解栈帧的结构？我们还是先来回顾（review）以下有哪些和函数栈相关的寄存器吧。（这儿并没有包含浮点寄存器）  \n\n\n所谓调用者保存，就是可以让被调用者（自身不作为另一个调用者）随意使用，也是为了自己用到的数据不被覆盖。\n\n所谓被调用者保存，恰恰与调用者保存相反。\n\n函数调用一般参数传递（非浮点）前6个参数存于寄存器，剩下的参数按照函数定义从右向左压栈。\n\n栈指针指向函数栈栈顶。\n\n%rax 用于保存函数调用返回值。  \n  了解了这些寄存器，我们再来看看栈帧的结构\n\n\n\n就拿函数P的栈帧来说，从栈底到栈顶的方向分别存储以下内容：\n\n被保存的寄存器\n\n局部变量（sub $0x18,%rsp ）\n\n如果调用其他函数参数多于6，便有参数构造区\n\n调用其他函数时需要将返回地址压栈\n\n\n","categories":["随笔浅记"],"tags":["low-level","asm"]},{"title":"一些rustlings题目","url":"/2024/10/10/%E4%B8%80%E4%BA%9Brustlings%E9%A2%98%E7%9B%AE/","content":"iteratoriterators2// iterators2.rs//// In this exercise, you&#x27;ll learn some of the unique advantages that iterators// can offer. Follow the steps to complete the exercise.//// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a// hint.// I AM NOT DONE// Step 1.// Complete the `capitalize_first` function.// &quot;hello&quot; -&gt; &quot;Hello&quot;pub fn capitalize_first(input: &amp;str) -&gt; String &#123;    let mut c = input.chars();    match c.next() &#123;        None =&gt; String::new(),        Some(first) =&gt; first.to_uppercase().to_string()+c.as_str(),    &#125;&#125;// Step 2.// Apply the `capitalize_first` function to a slice of string slices.// Return a vector of strings.// [&quot;hello&quot;, &quot;world&quot;] -&gt; [&quot;Hello&quot;, &quot;World&quot;]pub fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; &#123;    let mut c =vec![];    words.iter().for_each(|x| c.push(capitalize_first(x)));    c&#125;//// Step 3.// Apply the `capitalize_first` function again to a slice of string slices.// Return a single string.// [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;] -&gt; &quot;Hello World&quot;pub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String &#123;    let mut s = String::new();    words.iter().for_each(|x| s+=capitalize_first(x).as_str());    s&#125;//另一种方法pub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String &#123;    // let mut s = String::new();    // words.iter().for_each(|x| s+=capitalize_first(x).as_str());    let s =words.iter().map(|x| capitalize_first(x)).collect::&lt;String&gt;();    s&#125;#[cfg(test)]mod tests &#123;    use super::*;    #[test]    fn test_success() &#123;        assert_eq!(capitalize_first(&quot;hello&quot;), &quot;Hello&quot;);    &#125;    #[test]    fn test_empty() &#123;        assert_eq!(capitalize_first(&quot;&quot;), &quot;&quot;);    &#125;    #[test]    fn test_iterate_string_vec() &#123;        let words = vec![&quot;hello&quot;, &quot;world&quot;];        assert_eq!(capitalize_words_vector(&amp;words), [&quot;Hello&quot;, &quot;World&quot;]);    &#125;    #[test]    fn test_iterate_into_string() &#123;        let words = vec![&quot;hello&quot;, &quot; &quot;, &quot;world&quot;];        assert_eq!(capitalize_words_string(&amp;words), &quot;Hello World&quot;);    &#125;&#125;\n\n奇怪的报错\niterators5fn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize &#123;    // map is a hashmap with String keys and Progress values.    // map = &#123; &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... &#125;    // 要使用迭代器来重现计数功能，可以使用filter方法过滤出具有指定进度值的元素，    // 并使用count方法计算满足条件的元素数量。    map.values().filter(|&amp;progress| *progress == value).count()&#125;//我的写法fn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize &#123;    // map is a hashmap with String keys and Progress values.    // map = &#123; &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... &#125;    // todo!();    let count:usize=map.iter().filter(|(_,v)| **v==value).count();    count&#125;fn count_collection_for(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize &#123;    let mut count = 0;    for map in collection &#123;        for val in map.values() &#123;            if val == &amp;value &#123;                count += 1;            &#125;        &#125;    &#125;    count&#125;fn count_collection_iterator(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize &#123;    // collection is a slice of hashmaps.    // collection = [&#123; &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... &#125;,    //     &#123; &quot;variables2&quot;: Complete, ... &#125;, ... ]    // todo!();    // 需要先展平这个切片，然后再进行过滤和计数。    // 可以使用flat_map方法将切片中的每个HashMap转换为一个迭代器，    // 然后使用filter方法过滤出具有指定进度值的元素，    // 最后使用count方法计算满足条件的元素数量。    collection.into_iter()    .flat_map(|x| x.values())    .filter(|&amp;progress| *progress == value)    .count()&#125;\n\nconversions// Your task is to complete this implementation in order for the line `let p =// Person::from(&quot;Mark,20&quot;)` to compile Please note that you&#x27;ll need to parse the// age component into a `usize` with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The// outcome of this needs to be handled appropriately.//// Steps:// 1. If the length of the provided string is 0, then return the default of//    Person.// 2. Split the given string on the commas present in it.// 3. Extract the first element from the split operation and use it as the name.// 4. If the name is empty, then return the default of Person.// 5. Extract the other element from the split operation and parse it into a//    `usize` as the age.// If while parsing the age, something goes wrong, then return the default of// Person Otherwise, then return an instantiated Person object with the results// I AM NOT DONEimpl From&lt;&amp;str&gt; for Person &#123;    fn from(s: &amp;str) -&gt; Person &#123;    if s.len()==0&#123;       return Person::default();    &#125;    let mut x:Vec&lt;&amp;str&gt; = s.split(&quot;,&quot;).collect();    if x.len() != 2 &#123;        return Person::default();    &#125;    let name = x[0].trim();    if name.is_empty()&#123;        return Person::default();    &#125;            match x[1].parse::&lt;usize&gt;()&#123;            Ok(age)=&gt;Person&#123;                name:name.to_string(),                age            &#125;,            Err(_) =&gt; Person::default()        &#125;    &#125;&#125;\n\nheap(作为对heap的复习)/*\theap\tThis question requires you to implement a binary heap function*/// I AM NOT DONEuse std::cmp::Ord;use std::default::Default;pub struct Heap&lt;T&gt;where    T: Default,&#123;    count: usize,    items: Vec&lt;T&gt;,    comparator: fn(&amp;T, &amp;T) -&gt; bool,&#125;impl&lt;T&gt; Heap&lt;T&gt;where    T: Default,&#123;    pub fn new(comparator: fn(&amp;T, &amp;T) -&gt; bool) -&gt; Self &#123;        Self &#123;            count: 0,            items: vec![T::default()],            comparator,        &#125;    &#125;    pub fn len(&amp;self) -&gt; usize &#123;        self.count    &#125;    pub fn is_empty(&amp;self) -&gt; bool &#123;        self.len() == 0    &#125;    pub fn add(&amp;mut self, value: T) &#123;        //TODO        self.items.push(value);        self.count += 1;        let mut idx = self.count;        while idx &gt; 1 &amp;&amp; (self.comparator)(&amp;self.items[idx], &amp;self.items[idx / 2]) == true &#123;            self.items.swap(idx, idx / 2);            idx /= 2;        &#125;;//加入后不断上浮对父节点进行比较直到到达顶点或小/大于父节点    &#125;    fn parent_idx(&amp;self, idx: usize) -&gt; usize &#123;        idx / 2    &#125;    fn children_present(&amp;self, idx: usize) -&gt; bool &#123;        self.left_child_idx(idx) &lt;= self.count    &#125;    fn left_child_idx(&amp;self, idx: usize) -&gt; usize &#123;        idx * 2    &#125;    fn right_child_idx(&amp;self, idx: usize) -&gt; usize &#123;        self.left_child_idx(idx) + 1    &#125;    fn smallest_child_idx(&amp;self, idx: usize) -&gt; usize &#123;        //TODO        let left_child = self.left_child_idx(idx);        let right_child = self.right_child_idx(idx);        if right_child &gt; self.count || (self.comparator)(&amp;self.items[left_child], &amp;self.items[right_child]) == true &#123;            left_child        &#125; else &#123;            right_child        &#125;//right_child不存在或左节点比右节点大/小    &#125;&#125;impl&lt;T&gt; Heap&lt;T&gt;where    T: Default + Ord,&#123;    /// Create a new MinHeap    pub fn new_min() -&gt; Self &#123;        Self::new(|a, b| a &lt; b)    &#125;    /// Create a new MaxHeap    pub fn new_max() -&gt; Self &#123;        Self::new(|a, b| a &gt; b)    &#125;&#125;impl&lt;T&gt; Iterator for Heap&lt;T&gt;where    T: Default+Copy,&#123;    type Item = T;    fn next(&amp;mut self) -&gt; Option&lt;T&gt; &#123;        //TODO        if !self.is_empty() &#123;            self.items.swap(1, self.count);            let res = self.items.swap_remove(self.count);            self.count -= 1;                        // SWIM            let mut idx: usize = 1;            let mut smallest_child_idx = self.smallest_child_idx(idx);            while smallest_child_idx &lt;= self.count &amp;&amp; (self.comparator)(&amp;self.items[smallest_child_idx], &amp;self.items[idx]) &#123;                self.items.swap(smallest_child_idx, idx);                idx = smallest_child_idx;                smallest_child_idx = self.smallest_child_idx(smallest_child_idx);            &#125;;            Some(res)        &#125; else &#123;            None        &#125;    &#125;//如果堆不为空，交换顶点和最小节点，然后检测下沉，如果顶点小/大于子节点，则不断下沉交换。    //因为add的上浮操作导致堆的顶点的下方是无序的，需要不断下沉保证堆的性质    &#125;pub struct MinHeap;impl MinHeap &#123;    #[allow(clippy::new_ret_no_self)]    pub fn new&lt;T&gt;() -&gt; Heap&lt;T&gt;    where        T: Default + Ord,    &#123;        Heap::new(|a, b| a &lt; b)    &#125;&#125;pub struct MaxHeap;impl MaxHeap &#123;    #[allow(clippy::new_ret_no_self)]    pub fn new&lt;T&gt;() -&gt; Heap&lt;T&gt;    where        T: Default + Ord,    &#123;        Heap::new(|a, b| a &gt; b)    &#125;&#125;#[cfg(test)]mod tests &#123;    use super::*;    #[test]    fn test_empty_heap() &#123;        let mut heap = MaxHeap::new::&lt;i32&gt;();        assert_eq!(heap.next(), None);    &#125;    #[test]    fn test_min_heap() &#123;        let mut heap = MinHeap::new();        heap.add(4);        heap.add(2);        heap.add(9);        heap.add(11);        assert_eq!(heap.len(), 4);        assert_eq!(heap.next(), Some(2));        assert_eq!(heap.next(), Some(4));        assert_eq!(heap.next(), Some(9));        heap.add(1);        assert_eq!(heap.next(), Some(1));    &#125;    #[test]    fn test_max_heap() &#123;        let mut heap = MaxHeap::new();        heap.add(4);        heap.add(2);        heap.add(9);        heap.add(11);        assert_eq!(heap.len(), 4);        assert_eq!(heap.next(), Some(11));        assert_eq!(heap.next(), Some(9));        assert_eq!(heap.next(), Some(4));        heap.add(1);        assert_eq!(heap.next(), Some(2));    &#125;&#125;"},{"title":"一点碎碎念","url":"/2024/10/05/%E4%B8%80%E7%82%B9%E7%A2%8E%E7%A2%8E%E5%BF%B5/","content":"\n      \n        8e86f178584edd2ab7a1677137b40296aea0d4883b824000480fb631f50f611292f0aba103237d2bf61a31bb078f834bd7c4723ba24a6eee923a1a08e0ab0aa3578ebfa3b6d92b5ce0e4d0017735e2c09f9caeeadfb1d98cbcbd3ca1261c684d7bdd2e0d46aea459cc54d3049030d9f660990b3f30c6946ae17ff911f7f0a69e0d6d05b469c18f394915b763dd4800c4580c17a40cf381aaebb17d813d3e4a2c7f659a9fb29f05af2f32663eb899bd546c827e42c31ac055e7eeec9c92463178438e743d6d3726a9929af1c5ba5c900c72712fba30a861607c858954c2876291\n      \n      \n        \n          \n          \n            未来机关授权密钥\n          \n        \n        \n      \n    \n    ","categories":["生活杂谈"],"tags":["生活","思考"]},{"title":"写在之前","url":"/2024/09/29/%E5%86%99%E5%9C%A8%E4%B9%8B%E5%89%8D/","content":"一个学期文章没写多少，博客倒是换了五六次。这次大概不会再换了，大概。\n","categories":["随笔浅记"],"tags":["生活"]},{"title":"在 Rust 中使用字符串","url":"/2024/10/04/%E5%9C%A8%20Rust%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"机翻摘抄自 Working with strings in Rust\n从C开始\n当人们学习Rust编程语言时，总会出现一个问题：为什么有两种字符串类型？为什么有String和&amp;str ？\n作者先从一个C语言程序入手：\n_// in `print.c`__int_ _main_(_int_ _argc_, _char_ _*__*__argv_) &#123;    _printf_(_&quot;argv = %p\\n&quot;_, _argv_); _// new!_    _for_ (_int_ _i_ _=_ _0_; _i_ _&lt;_ _argc_; _i__++_) &#123;        _char_ _*__arg_ _=_ _argv_[_i_];        _printf_(_&quot;argv[%d] = %p\\n&quot;_, _i_, _argv_[_i_]); _// new!_        _printf_(_&quot;%s\\n&quot;_, _arg_);    &#125;    _return_ _0_;&#125;\n看看结果，看起来不错！\n$ gcc print.c -o print$ ./print &quot;ready&quot; &quot;set&quot; &quot;go&quot;./printreadysetgo\n\n现在看看我们到底在做什么\n_// in `print.c`__int_ _main_(_int_ _argc_, _char_ _*__*__argv_) &#123;    _printf_(_&quot;argv = %p\\n&quot;_, _argv_); _// new!_    _for_ (_int_ _i_ _=_ _0_; _i_ _&lt;_ _argc_; _i__++_) &#123;        _char_ _*__arg_ _=_ _argv_[_i_];        _printf_(_&quot;argv[%d] = %p\\n&quot;_, _i_, _argv_[_i_]); _// new!_        _printf_(_&quot;%s\\n&quot;_, _arg_);    &#125;    _return_ _0_;&#125;\n\n\nNow we’re using the %p format specifier, which prints.. pointers!现在我们使用%p格式说明符，它打印..指针！\n\n$ gcc print.c -o print$ ./print &quot;ready&quot; &quot;set&quot; &quot;go&quot;argv = 0x7ffcc35d84a8argv[0] = 0x7ffcc35d9039./printargv[1] = 0x7ffcc35d9041readyargv[2] = 0x7ffcc35d9047setargv[3] = 0x7ffcc35d904bgo\n\n于是我们知道，argv是一个地址数组那么%s如何知道自己何时停止打印？作者的代码copy过来不太方便，于是直接上图\n\n让我们尝试将我们的程序通过管道传输到像xxd这样的十六进制转储器中，以准确查看发生了什么：\n$ # note: &quot;-g 1&quot; means &quot;show groups of one byte&quot;,$ # xxd defaults to &quot;-g 2&quot;.$ ./print &quot;ready&quot; &quot;set&quot; &quot;go&quot; | xxd -g 100000000: 2e 2f 70 72 69 6e 74 00 72 65 61 64 79 00 73 0a  ./print.ready.s.00000010: 72 65 61 64 79 00 73 65 74 00 67 6f 00 43 44 0a  ready.set.go.CD.00000020: 73 65 74 00 67 6f 00 43 44 50 41 54 48 3d 2e 0a  set.go.CDPATH=..00000030: 67 6f 00 43 44 50 41 54 48 3d 2e 3a 2f 68 6f 0a  go.CDPATH=.:/ho.\n\n00000000: 2e 2f 70 72 69 6e 74 00 72 65 61 64 79 00 73 0a  ./print.ready.s.          .  /  p  r  i  n  t  ^^ r  e  a  d  y  ^^\n我们发现他用00分割了每个参数，事实上，C具有以null(0)结尾的字符串。所以%s等价于一个在0上break的%c打印程序。\n&#x3D;&#x3D;You may have noticed that when our print program went beyond the end of our arguments, it showed CDPATH=.:/ho too.That was (part of) an environment variable! Those are stored right next to the program’s arguments in glibc, the GNU C library.But the specifics are out of scope for this article, you may want to check out the Making our own executable packer series instead.您可能已经注意到，当我们的打印程序_超出_参数末尾时，它也显示CDPATH=.:/ho 。那是环境变量（的一部分）！它们存储在 GNU C 库 glibc 中程序参数的旁边。但具体细节超出了本文的范围，您可能想查看“制作我们自己的可执行加壳器”系列 &#x3D;&#x3D;\n现在进行最后一个测试\n$ gcc print.c -o print$ ./print &quot;élément&quot;éLéMENT\n好像出现了一点问题，实际我们想要的是“ÉLÉMENT”，好吧，让我们试试更简单的事情——打印每个字符%c并用空格隔开。\n_// in `print.c`__#include_ _&lt;stdio.h&gt;_ _// printf__int_ _main_(_int_ _argc_, _char_ _*__*__argv_) &#123;    _for_ (_int_ _i_ _=_ _1_; _i_ _&lt;_ _argc_; _i__++_) &#123;        _char_ _*__arg_ _=_ _argv_[_i_];        _for_ (_int_ _j_ _=_ _0_;; _j__++_) &#123;            _char_ _character_ _=_ _arg_[_j_];            _if_ (_character_ _==_ _0_) &#123;                _break_;            &#125;            _// notice the space following `%c`_            _printf_(_&quot;%c &quot;_, _character_);        &#125;        _printf_(_&quot;\\n&quot;_);    &#125;    _return_ _0_;&#125;\n\n$ gcc print.c -o print$ ./print &quot;élément&quot;  l   m e n t\n不太行……还是再看看xxd好吗？\ngcc print.c -o print$ ./print &quot;élément&quot; | xxd -g 100000000: c3 a9 6c c3 a9 6d 65 6e 74 0a                    ..l..ment.          ^^^^^    ^^^^^\n问题就在于，É实际上是两个bytec3 a9，即使我们使用nodejs书写一样如此，为什么他的编码是c3 a9？是时候学习一下utf-8了。\n快速UTF-8入门","categories":["随笔浅记"],"tags":["Rust"]},{"title":"域名上踩的一个小坑","url":"/2024/06/23/%E5%9F%9F%E5%90%8D%E4%B8%8A%E8%B8%A9%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/","content":"经过将近半个月的折腾，总算在halo上安定下来。然而域名解析上却频频出事。\nIP解析正常，但是域名必须加上端口才能访问。\n经过一系列排查：vps防火墙、nginx配置、各种CDN开开关关都试了一遍。依然没找到问题所在。最后经过群里讨论确定问题出在没有走nginx的代理。\n折腾好久之后终于发现——原来是系统内部的防火墙没有开放80&#x2F;443端口，而我只检查了VPS提供商的外部防火墙。\n虽然最后解决了，但隐隐约约还是有点不爽。大抵是因为问的问题又被人看不上了吧。我尽我所能排查总结，却还是不出意外地受到了轻蔑和指指点点。\n這就是為什麼我討厭互聯網，大專水平提问题非常轻易地就会被look down upon，即使我已经尽我所能地去排查问题和总结情况。\n可是我能怎麼辦呢，要不下次說我是學藥學的吧？\n","categories":["随笔浅记"],"tags":["前端"]},{"title":"如何跳转到页面某个位置","url":"/2024/05/24/%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BD%AC%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE/","content":"如何跳转到页面某个位置\n\ngetBoundingClientRect() 是 JavaScript 中的一个非常有用的方法，它属于 Element 对象。这个方法返回一个 DOMRect 对象，该对象包含了元素的大小及其相对于视口（viewport）的位置。DOMRect 对象包含了一组只读属性：top、right、bottom、left、width 和 height，这些属性描述了元素的边界框。\n注意我们获取到的是相对值，元素滚动后视口与元素之间的距离发生改变会导致功能不好使，必须加上一个window.pageYOffset 。\n这是一个比较现代的方法。\n","categories":["随笔浅记"],"tags":["前端"]},{"title":"微训领航一面面经","url":"/2024/07/27/%E5%BE%AE%E8%AE%AD%E9%A2%86%E8%88%AA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/","content":"前30min\n自我介绍\n\n如何学习前端\n\n项目介绍\n\n\n八股吟唱\nvar let const 区别\n\nfor in for of区别\n\n原型和原型链\n\n闭包\n\n箭头函数\n\n跨域\n\n基本数据类型和引用类型\n\nsplice和slice\n\n知道promise吗\n\n垂直水平居中的方法\n\n宏任务与微任务\n\n知道Set吗\n\n输入域名到进入网页中间经历了什么\n\nDNS解析\n\n从服务器获取静态资源\n\nHTML和CSS渲染\n\n\n\nreact的hook你知道几个\n\n\n场景题和算法\n看代码说输出\n\nconsole.log(&quot;Start&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;Timeout&quot;);&#125;, 0);Promise.resolve().then(() =&gt; &#123;    console.log(&quot;Promise&quot;);&#125;);console.log(&quot;End&quot;);\n\nfunction MyComponent() &#123;    const [count, setCount] = useState(0);    useEffect(() =&gt; &#123;        console.log(&#x27;useEffect&#x27;);        return () =&gt; &#123;            console.log(&#x27;Cleanup&#x27;);        &#125;;    &#125;, []);    useEffect(() =&gt; &#123;        console.log(&#x27;count refresh&#x27;);    &#125;, [count]);    console.log(&#x27;Function body&#x27;);    return (        &lt;div&gt;            &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;        &lt;/div&gt;    );&#125;\n\n\n实现一个穿梭表 https://ant.design/components/transfer-cn\n\n算术表达式二叉树\n\n\ninterface RootNode &#123;    type: &quot;operator&quot; | &quot;number&quot;;    operator?: &quot;+&quot; | &quot;-&quot;    value?: number    // 如果是操作符，那么一定有左右子节点    left?: RootNode    right?: RootNode&#125;// 1 + 1 + 1const root: RootNode = &#123;    type: &quot;operator&quot;,    operator: &quot;+&quot;,    left: &#123;        type: &quot;number&quot;,        value: 1,    &#125;,    right: &#123;        type: &quot;operator&quot;,        operator: &quot;+&quot;,        left: &#123;            type: &quot;number&quot;,            value: 1        &#125;,        right: &#123;            type: &quot;number&quot;,            value: 1        &#125;    &#125;&#125;// 实现算法计算一个表达式树的值function evaluate(root: RootNode): number &#123;    &#125;// 将一个表达式树转换为表达式字符串function toExpression(root: RootNode): string &#123;    &#125;\n\n反问\n有什么建议吗？“回去多学学数据结构和算法再来吧”\n\n","categories":["八股面经"],"tags":["面经"]},{"title":"氓","url":"/2024/09/29/%E6%B0%93/","content":"氓之蚩蚩，抱布贸丝。匪来贸丝，来即我谋。送子涉淇，至于顿丘。匪我愆期，子无良媒。将子无怒，秋以为期。乘彼垝垣，以望复关。不见复关，泣涕涟涟。既见复关，载笑载言。尔卜尔筮，体无咎言。以尔车来，以我贿迁。桑之未落，其叶沃若。于嗟鸠兮，无食桑葚！于嗟女兮，无与士耽！士之耽兮，犹可说也。女之耽兮，不可说也。桑之落矣，其黄而陨。自我徂尔，三岁食贫。淇水汤汤，渐车帷裳。女也不爽，士贰其行。士也罔极，二三其德。三岁为妇，靡室劳矣。夙兴夜寐，靡有朝矣。言既遂矣，至于暴矣。兄弟不知，咥其笑矣。静言思之，躬自悼矣。及尔偕老，老使我怨。淇则有岸，隰则有泮。总角之宴，言笑晏晏。信誓旦旦，不思其反。反是不思，亦已焉哉！\n","categories":["生活杂谈"],"tags":["古诗文"]},{"title":"深夜的浅色床单与指尖流沙","url":"/2024/06/16/%E6%B7%B1%E5%A4%9C%E7%9A%84%E6%B5%85%E8%89%B2%E5%BA%8A%E5%8D%95%E4%B8%8E%E6%8C%87%E5%B0%96%E6%B5%81%E6%B2%99/","content":"\n      \n        8e86f178584edd2ab7a1677137b40296df239d718eb7826815058b017e9733bd9ad60f9df43537b77103e62c7032c8486af3f44e8d9ebb48dc26e914116bca965187606b464deb10f113ad4c9635f8c739b2c5ca6a3f0564df84679631e39543d2cf44f70ddfffe7a3e2c00711ec29effd33f555fed618d01f123a597cfff8832d4946386d82f7972c326f32bfbd4d6303f32065a0c64af0ffa6bdcf22c92a81aa9e7ec326297302c6f34f793c12e1ac63f323ad2849bf6ae29a731fbbbe760ef116ce583afe3255924f5e8ee8c4d0054b1555695e3c0a064de194ac687091d6a5142883fdf71623d8f10a310cb0f502d4c1e01adf9b9c8223f858ce871531f806151a4cb60ed56e2b555013b5c88337ff443119b4b78ca3f24ba244d8a26c0a4ae3651908a4c59de6e07c5842b99e05653bb96af403a9c3e02449dfdeca0d8dec48d471d9d428a0442fd905f34d8e12a913c60782e9bad2a87272ecbf902b7898776dfef5675b0072a3a40dd9d70de8ee02219b2dc79978b8db7622179f2ff3afec6ddf3a064605f98a48fc776ba74057ae8c25ecbd13e8a57a692b3714738c3a21091a8403f636d9ece784665571af7909269864440548bd85853909e8807f3974434ee9058ac9ee94f077201c48b40d17a101bebe584dea317cf6ceb916cb5f01302844c91e6b3c3285005f2f99d11fecdb3e1835663d59e68af41b6b461409243e4240c9c1ccdf45d134ac410a073a045c3fe4524ef3f953d55f47238f292b91ad83347ec624c249b2a122b328860a8cfd6733872fd6f36bd3c115e186b2bfca05ffd5f420a7dc542c2214bfe042234d5d6663e9a289ebaa845f098d3c4c024a7278316dd1a7b27f3ec4f3d9f788f21db1cc35a3ea26a3f8f0bee21cf76499f1541500703130592e03c101a1169e0bca59251573fe4a90856a88689f0403318fb0c648b810c3927e3fe6845901467fc31c095b1142203d913c7d1b1454fd88515295f05ac1945f7524d0740df4178ece7b89f630a1a5f044e07fd8d5655fc526bbe71c4478948e418f2e7614e710b947996033852d91e191eee01b0fffe525822e2a5caa3c574197fbd471145f10f5934d46ac154cb74fae7c24be31f2dc01aba3ae008d30164086122c9951d8c17520c36e09087f92dad7d5a8bbda0c7dec0a6fb0e1211557a31ec8cdfd1414bbc392cb184a5e897ffc5a1161d3b511514b0461539bdd99b4b8a97ed4ca66904fbb8cd08b71d84a88dd09e1847885653efb54627e34e52a01cf0cb20a84f8fc774f268ae826fb387c188345ee0ac91cc3c7e137e8ba7192e8b8a8e15c49f00e81cf8ad65ea45fd5c6de0d190dc21de578d07305ff3e710b69a252609d9668b9828f26fe83ba6e211bdf47aca3198896b442fc706aaab6ac630ada66524237677e18bace0f8fff56bcb0d0a9423aa8c38ee157b2f3aa912b802c018eb62afa92d98fc8140eaaba016d0e6315cb64450a5bc995633d8a99609deb15e8aae23f563f666ab25253cfeb9dc4a8d46e6e5238209e73fee5936d8c4b293aea4ffb188010f7a5026e95da0923b4f53baf1a5a9d03b61242a9de006a8ff107125260c51eca8b8e289521e2ca2cbab2950c217d11242edd581e9e1001046d978776db73d2c4f133c47bbde5a0ee4de969d449e9813f86505430e8c39d03efac6b99ec79295280ea84bcffdae9fb5fe83972dd713b25ac6bde56109e5b99a3c0e53e9a709044cfbbcb4df7ef31872af931c644ef860aa80ab5b4c01bcbdb59f590dd845f8cffad2f44130672740d3c2c6ebb004fe9d6d6692d08252b92dc84b581a9c25218e680a9924412d6e81277dde408597337a8128c77a03232720dbcd60e193eb0c566a635b868513b22cd0cedb32d6168f8e8bd0e37abf227b2b275057acf9c8da049fd3edefbc1b28ff1c7e16a64e5509e003f27545ed46564c55cd7ef727359dfa54b509ceaf7ef279f4e090e485d328df2ca1568558e151a5e177230b2d084ce96c9d18528530205363a42976f8800f5a0dc17e3e9aeababca3603a195e734dc01af44b561fb6a977f2db343035c66f79543f86bd10bec2c98c4f8e4fce7c563835816027d0283c171d44438439c34a6536607e9876b621186fddbd5b052602916821e4790eb1ac826e112b048ceb2470d2d90bc3e99680e0e02e46f750224484fac249f019678ad9157bb2760cfcf748d98b0373db7fe6bc205062081e84f92175ae14ffe509b53e294079b9f757a5bf4d10749c0f49c0486848d559359e88597b65a025ba7725e4d59b6ba10df6ff55030347de31066c89be615b0fe5b911a4cbfd516595c10b66e4d5e3ed575a7b59b55202241d7586308e72ef7e2df9b5be9729eb90ffd649e9d3cf778e465a2a34c8ea42d4bea7a9ee1b77d1ba9c0fa3cf71c6b0c97e915798183b7c6a44c187c5342ed134a9b56d24f08653c766e5c2d0594dbd96c98f98d7d3a98db5783ac5b757bfb4c8883b35119ff3097e2420590e5acb9ecdae3eaf1561c2610ce241574df0f1cdae402a7e613f1ff4216672f65934c2fcec2da31bd6459616605b6030daacbee70cd594db4a77bfc6c7ee073a6353d7d90e2153c5168347b40f5ba16210c5c4df267992052da1b0a0be24cf681f7927f72da3efa43ed3b30c62a344d4bdf0141494f8dc19f74958f83cc6369a33e915efb071c05a020db976fe88316b1fd8c8a1c2407cae8df1ca1fc6e85bcf7c18b8f4e6f5f5688da1ba6a7840c171e9ae637d231c71b75ebf42a39b33e58e05f2dbef63bc260c7d598a02159057af22103a294a641fce25c12116ad3d0c734ab\n      \n      \n        \n          \n          \n            未来机关授权密钥\n          \n        \n        \n      \n    \n    ","categories":["生活杂谈"],"tags":["生活","思考"]},{"title":"由61C P1开始的指针笔记","url":"/2024/07/15/%E7%94%B161C%20P1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/","content":"写61C P1的时候写出来这么一段代码\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;int count = image-&gt;cols*image-&gt;rows;image-&gt;image = (Color**)malloc(sizeof(Color*) * count);Color *evaluateOneCell(Image *image, int row, int col, uint32_t rule)&#123;\t// YOUR CODE HERE\tfor(int i = 0; i &lt; 6; i++)&#123;\t\tColor *pp =*(image-&gt;image+i);\t\tprintf(&quot;%3hhu %3hhu %3hhu&quot;,pp-&gt;R,pp-&gt;G,pp-&gt;B);\t&#125;&#125;\n\n我的问题在于不能理解\nColor *pp =*(image-&gt;image+i);\n\n这段代码表达的是什么？\n我的基础很差，很多代码细节都是仰仗PKU大佬来进行“学术不端”。但是之后还要继续挑战S081和ysyx,所以我必须要弄懂这些。\n以下内容多数来自C Pointers。\n首先我们知道，数组在内存中是连续存储的，而指针归根到底是指向地址的变量。\n指针的使用一个简单的例子int var = 10;int * ptr;ptr = &amp;var;\n\n指针解引用\n指针解引用是访问\nre pointer variable    int* ptr;    // note that data type of ptr and var must be same    ptr = &amp;var;    // assign the address of a variable to a pointer    printf(&quot;Value at ptr = %p \\n&quot;, ptr);    printf(&quot;Value at var = %d \\n&quot;, var);    printf(&quot;Value at *ptr = %d \\n&quot;, *ptr);&#125;// Driver programint main()&#123;    geeks();    return 0;&#125;\n\n输出\nValue at ptr = 0x7ffca84068dc Value at var = 10 Value at *ptr = 10 \n\n双指针在C语言中，我们可以创建指向指针的指针，以下是对原文的翻译。\n\n*pointer_name; // get the address stored in the inner level pointer获取内部指针储存的地址**pointer_name; // get the value pointed by inner level pointer获取内部指针地址\n\n\nNote: In C, we can create multi-level pointers with any number of levels such as – ***ptr3, ****ptr4, ******ptr5 and so on.\n\n\n最后写一下开头问题的答案吧这行代码Color *p =*(image-&gt;image + (newrow * image-&gt;cols + newcol));尝试做的是：\n\n计算newrow * image-&gt;cols + newcol，这给出了从图像开始到指定行和列的偏移量（假设图像数据是连续的，并且按行优先顺序排列）。\n\nimage-&gt;image + ...将image-&gt;image指针向前移动这个偏移量的位置。\n\n然后，*(...)试图解引用这个新的指针位置，但由于image-&gt;image很可能是一个指向Color类型（或类似类型，表示颜色的结构体）的指针，这里的解引用并不直接指向Color类型的值，而是指向了包含Color类型值的数组的一个Color元素。因此，理论上，直接解引用后赋值给Color*类型的指针p是合理的，但写法上有些绕。\n\n\n以上摘抄自文心一言，我个人的理解是*(...) 的括号里实际上是指向了一长串指针数组里的第一个数组索引的地址，因此当我们解引用时，我们实际得到了数组索引指向的地址，也就是元素本身的地址，最后再用Color*储存起来。\n以上就是这篇博文的大概内容了，我想再多写一些，可惜现在太晚了熬不住了，知识储备也不够，希望能在学习一些ysyx之后再来补充吧！\n其实有点伤心的，作为一个学习者，我追求的并不只是勉强看懂，而是能在需要的时候信手拈来。然而这么久我却依然没法好好的写完一个正式的project，感受coding的魅力。\n","categories":["随笔浅记"],"tags":["CS61C","指针"]}]