[{"title":"CORS跨域","url":"/2024/09/29/CORS%E8%B7%A8%E5%9F%9F/","content":"\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n简单请求\n添加一个origin字段\n服务器判断origin是否被许可\n不许可不添加Access-Control-Allow-Origin，否则添加\n具体格式如下：\n\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\n\n\n非简单请求\n预检请求：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n请求头格式：options表示询问， Access-Control-Request-Method：列出使用了的方法\nOPTIONS &#x2F;cors HTTP&#x2F;1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0…\n\n\n如果否定，则服务器返回一个没有任何相关头的字段，浏览器报错\n\n解决方法\n浏览器插件\n后端配置cors\n如果需要cookie,需要前端一起配合\n\n","categories":["随笔浅记"],"tags":["前端"]},{"title":"Rust笔记","url":"/2024/09/29/Rust%E7%AC%94%E8%AE%B0/","content":"学学rust！\n","categories":["随笔浅记"],"tags":["Rust"]},{"title":"Hello World","url":"/2024/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"x86笔记","url":"/2024/09/29/x86%E7%AC%94%E8%AE%B0/","content":"对X86寄存器、概念和常见指令做一个笔记。\n笔记来源自各大网站、博客。\n常见寄存器作用：x86-64 架构的寄存器有一些使用习惯，比如：\n\n用来传参数的寄存器：%rdi, %rsi, %rdx, %rcx, %r8, %r9\n\n保存返回值的寄存器：%rax\n\n被调用者保存状态：%rbx, %r12, %r13, %r14, %rbp, %rsp\n\n调用者保存状态：%rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11\n\n栈指针：%rsp\n\n指令指针：%rip\n\n\n函数调用约定：\n%rdi：第一个参数\n\n%rsi：第二个参数\n\n%rdx：第三个参数\n\n%rcx：第四个参数\n\n%r8：第五个参数\n\n%r9：第六个参数\n\n%rax：返回值\n\n\n数据传输指令：源目的地址:立即数,寄存器,存储器\n目的地址:寄存器,存储器\n(存储器不能到存储器)\nmov指令的五种形式：\nmovl 传送双字\nmovb 传送一个字节\nmovw 传送两个字节\n这里注意:\n&#x3D;&#x3D;movsbl&#x3D;&#x3D; &#x3D;&#x3D;movzbl&#x3D;&#x3D;指令负责拷贝一个字节,并设置目的操作数其余的位\n区别在于:\nmovsbl源操作数是单字节,move后将24位设置为源字节的最高位（在下列例子中为F）,然后拷贝到32位中。\nmovzbl 源操作数单字节,前面加24个0扩展到32位.然后拷贝到32位中.\nmov movsbl movzbl区别:\n//假设 %dh =8D,%eax=98765432 movb %dh %al      %eax=9876548D                              movsbl %dh %eax   %eax=FFFFFF8D movzbl %dh %eax   %eax=0000008D\n\n调用者保存与被调用者保存栈帧  \n想要了解栈帧的结构？我们还是先来回顾（review）以下有哪些和函数栈相关的寄存器吧。（这儿并没有包含浮点寄存器）  \n\n\n所谓调用者保存，就是可以让被调用者（自身不作为另一个调用者）随意使用，也是为了自己用到的数据不被覆盖。\n\n所谓被调用者保存，恰恰与调用者保存相反。\n\n函数调用一般参数传递（非浮点）前6个参数存于寄存器，剩下的参数按照函数定义从右向左压栈。\n\n栈指针指向函数栈栈顶。\n\n%rax 用于保存函数调用返回值。  \n  了解了这些寄存器，我们再来看看栈帧的结构\n\n\n\n就拿函数P的栈帧来说，从栈底到栈顶的方向分别存储以下内容：\n\n被保存的寄存器\n\n局部变量（sub $0x18,%rsp ）\n\n如果调用其他函数参数多于6，便有参数构造区\n\n调用其他函数时需要将返回地址压栈\n\n\n","categories":["随笔浅记"],"tags":["low-level"]},{"title":"写在之前","url":"/2024/09/29/%E5%86%99%E5%9C%A8%E4%B9%8B%E5%89%8D/","content":"今天是一个好日子，测试一下？\n","categories":["随笔浅记"],"tags":["生活"]},{"title":"氓","url":"/2024/09/29/%E6%B0%93/","content":"氓之蚩蚩，抱布贸丝。匪来贸丝，来即我谋。送子涉淇，至于顿丘。匪我愆期，子无良媒。将子无怒，秋以为期。乘彼垝垣，以望复关。不见复关，泣涕涟涟。既见复关，载笑载言。尔卜尔筮，体无咎言。以尔车来，以我贿迁。桑之未落，其叶沃若。于嗟鸠兮，无食桑葚！于嗟女兮，无与士耽！士之耽兮，犹可说也。女之耽兮，不可说也。桑之落矣，其黄而陨。自我徂尔，三岁食贫。淇水汤汤，渐车帷裳。女也不爽，士贰其行。士也罔极，二三其德。三岁为妇，靡室劳矣。夙兴夜寐，靡有朝矣。言既遂矣，至于暴矣。兄弟不知，咥其笑矣。静言思之，躬自悼矣。及尔偕老，老使我怨。淇则有岸，隰则有泮。总角之宴，言笑晏晏。信誓旦旦，不思其反。反是不思，亦已焉哉！\n","categories":["随笔浅记"],"tags":["生活"]}]