[{"title":"CORS跨域","url":"/2024/09/29/CORS%E8%B7%A8%E5%9F%9F/","content":"\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n简单请求\n添加一个origin字段\n服务器判断origin是否被许可\n不许可不添加Access-Control-Allow-Origin，否则添加\n具体格式如下：\n\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n\n\n\n非简单请求\n预检请求：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n请求头格式：options表示询问， Access-Control-Request-Method：列出使用了的方法\nOPTIONS &#x2F;cors HTTP&#x2F;1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0…\n\n\n如果否定，则服务器返回一个没有任何相关头的字段，浏览器报错\n\n解决方法\n浏览器插件\n后端配置cors\n如果需要cookie,需要前端一起配合\n\n","categories":["八股面经"],"tags":["前端","跨域"]},{"title":"CS61C P1摸鱼记","url":"/2024/07/09/CS61C%20P1%E6%91%B8%E9%B1%BC%E8%AE%B0/","content":"CS61C在20fa的P1是康威的生命游戏，涉及到了不少关于指针和内存的操作，发现自己学得太烂完全不会写，最后还是抄了PKU飞猪大佬的答案，因此特地开一篇文章记录一下相关内容和学习笔记。\nA1A1要求实现的是3个函数，&#x3D;&#x3D;readData&#x3D;&#x3D; ，&#x3D;&#x3D;writeData&#x3D;&#x3D;，和 &#x3D;&#x3D;freeImage&#x3D;&#x3D;。分别实现了\n\n将PPM文件转为IMAGE结构体\n\n将IMAGE结构体打印\n\n释放IMAGE结构体内存\n\n\n下面是代码答案，来自PKU的飞猪大佬的github。我偷了个懒，没有写NULL检查。\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;Image *readData(char *filename) &#123;\tImage *image = (Image*)malloc(sizeof(Image));\tchar format[3];\tFILE *fp = fopen(filename, &quot;r&quot;);\tint maxcolor;\tfscanf(fp, &quot;%s&quot;, format);\tfscanf(fp, &quot;%d %d&quot;, &amp;image-&gt;cols, &amp;image-&gt;rows);\tfscanf(fp, &quot;%d&quot;, &amp;maxcolor);\tint count = image-&gt;cols*image-&gt;rows;\timage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\tfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\t\treturn image;&#125;void writeData(Image *image)&#123;\tprintf(&quot;P3\\n%d %d\\n255\\n&quot;, image-&gt;cols, image-&gt;rows);\tColor** p = image-&gt;image;\tfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\t\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\t\tp++;\t\t&#125;\t\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;&#125;void freeImage(Image *image)&#123;\t\tint count = image-&gt;cols*image-&gt;rows;\tfor (int i = 0; i &lt; count; i++)\t&#123;\t\tfree(*(image-&gt;image+i));\t&#125;\t\tfree(image-&gt;image);\tfree(image);&#125;\n\n接下来我将记录一下里面关于数组和指针的一些内容。\n首先我们看看PPM文件的格式（其中一种）\n\nP3 &#x2F;&#x2F;格式\n4 5 &#x2F;&#x2F;列和行的数量\n255&#x2F;&#x2F;最大值\n0 0 0 0 0 0 0 0 0 0 0 0\n255 255 255 255 255 255 255 255 255 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n\nimage-&gt;image = (Color**)malloc(sizeof(Color*) * count);\n\n这行代码是对IMAGE对象的image指针进行分配内存，image指针是一个双重指针，一般指向的是一个二维数组——即数组的数组。\nfor(int i = 0; i &lt; count; i++)&#123;\t*(image-&gt;image + i) = (Color*)malloc(sizeof(Color));\tColor *pixel = *(image-&gt;image + i);\tfscanf(fp, &quot;%d %d %d&quot;, &amp;pixel-&gt;R, &amp;pixel-&gt;G, &amp;pixel-&gt;B);\t&#125;\n\n这段代码则是将像素点全部写入数组中，（image+i）代表将指针前推一个image中color的大小的值。我们可以想象指针在跳格子，每个格子都是一个color的大小。\n\n在C语言中，指针加上一个整数值可以表示地址偏移，这是因为指针在底层是以字节为单位进行偏移的。当你对指针加上一个整数值时，实际上是将指针指向的内存地址增加（或减少）相应的字节数，从而实现地址的偏移。\n例如，假设有一个指向整型数组的指针 int *ptr，如果你执行 ptr + 1，那么 ptr 将指向数组中下一个整型元素的地址，这是因为在C语言中，整型通常占据4个字节（取决于系统架构）。\n类似地，如果你有一个指向字符数组的指针 char *ptr，执行 ptr + 2 将使指针指向数组中第三个字符的地址，因为字符通常占据1个字节。\n以上内容取自gpt，以前我以为加数字是前进地址，类似于汇编。\n\n以及一个很重要的事情：**开了指针变量，一定要记得分配内存！**\nfor (int i = 0; i &lt; image-&gt;rows; i++) &#123;\tfor (int j = 0; j &lt; image-&gt;cols - 1; j++) &#123;\t\tprintf(&quot;%3hhu %3hhu %3hhu   &quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\t\tp++;\t&#125;\tprintf(&quot;%3hhu %3hhu %3hhu\\n&quot;, (*p)-&gt;R, (*p)-&gt;G, (*p)-&gt;B);\tp++;&#125;\n\n这段没有什么好说的，要注意的是%3hhu代表的是宽度为3位（不够的话会自动补全）的无符号字符。\n以下是我google出来的对%c和%hhu的解释。\n\n\n\nData Type 数据类型\nFormat Specifier 格式说明符\n\n\n\nchar 字符\n%c ％C\n\n\nsigned char 有符号字符\n%c (or %hhi for numerical output)  %c（或 %hhi 用于数字输出）\n\n\nunsigned char 无符号字符\n%c (or %hhu for numerical output)  %c（或 %hhu 用于数字输出）\n\n\nA2A2需要你设计一个隐写术（Steganography）程序。用的是LSB，比较简单，这里不多赘述。比较要注意的是(variable)-&gt;B不要写成variable-&gt;B了。\nB首先我们知道，我们需要两个（至少输入的时候是）参数，filename和rule。\ny有一个方法解析rule，将每一位都走一遍与运算，将结果放到数组上。有点像桶排序？在编写逻辑时就可以用了，好像不太优雅，先试着写吧\n结束：2024.7.15 1:10最后总算是写完了，完全没有诚信可言，最后疯狂地参考PKU大佬的答案修改。\n也算是练习了一下指针和valgrind吧。想写一篇关于指针的简单博客，之后会写的。\n","categories":["随笔浅记"],"tags":["CS61C"]},{"title":"JS基础引用类型","url":"/2024/05/28/JS%E5%9F%BA%E7%A1%80%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","content":"\nJS的基础类型有Number,String,Boolean,Undefined,Null,Symbol,Bigint，这些类型的变量储存在栈上（速度仅次于寄存器，但生命周期比较严格），引用类型有对象字面量、数组、函数等，储存在堆上。\n当我们写出如上图age&#x3D;oldage的语句时，此时age与oldage实际指向同一个基础类型变量地址的值。然而当我们改变age的值时，我们会在一个新的地址创建变量并指向它。\n然而当我们使用引用变量时，我们首先在堆上的D30F地址处创建了该对象，并在栈上创建了一个新的变量，变量的值指向堆上的地址D30F。当我们写出friend&#x3D;me时，我们实际是将friend指向了栈上0003地址处的D30F对象。\n这也是为什么对象是const常量但我们依然能改变其中属性的原因。因为我们实际并没有改变栈上变量指向的地址。\n","categories":["随笔浅记"],"tags":["JavaScript"]},{"title":"HTML笔记","url":"/2024/07/30/HTML%E7%AC%94%E8%AE%B0/","content":"如何使用a和id实现页面内跳转要在HTML中使用ID实现页面内的跳转，你可以使用`&lt;a&gt;`标签配合`href`属性来指向目标元素的ID。这里有一个简单的例子来说明如何操作：1. **定义一个带有ID的目标元素**：   ```html   &lt;div id=&quot;target&quot;&gt;     这是目标位置的内容。   &lt;/div&gt;   ```2. **创建一个链接到该目标元素的锚点**：   ```html   &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;   ```将这两个部分组合起来，你的HTML文件看起来可能是这样的：```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;页面内跳转示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;页面顶部&lt;/h1&gt;  &lt;p&gt;这是页面的起始部分。&lt;/p&gt;    &lt;!-- 创建一个链接到目标位置 --&gt;  &lt;a href=&quot;#target&quot;&gt;点击跳转到目标位置&lt;/a&gt;    &lt;p&gt;这里是其他内容...&lt;/p&gt;    &lt;!-- 定义带有ID的目标位置 --&gt;  &lt;div id=&quot;target&quot;&gt;    &lt;h2&gt;这是目标位置&lt;/h2&gt;    &lt;p&gt;这是目标位置的内容。&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;```当用户点击“点击跳转到目标位置”这个链接时，浏览器会滚动到ID为`target`的元素所在的位置。如果你希望在点击链接后平滑地滚动到目标位置，可以利用JavaScript或者HTML5中的`scroll-behavior: smooth;` CSS属性来实现平滑滚动效果。例如，在CSS中添加如下样式：```csshtml &#123;  scroll-behavior: smooth;&#125;```这样，当用户点击链接时，页面将会以平滑的方式滚动到目标位置。\n\nlink标签rel属性的prefetch预加载，在渲染之前提前解析好DNS拿好资源以加快加载速度\n浏览器渲染过程\n下载index.html\n\n解析\n\n下载相关资源（如css）\n\nhttps://www.51cto.com/article/771596.html\n\n\ntext-align对行内级元素进行居中处理（div这种块级元素要改成&#x3D;&#x3D;display:inline-block&#x3D;&#x3D;）\nem用作font-size时是父元素的X倍\n定位，你把一个元素一定位的话，它可能这个包含块就不再是它的父元素了\n文本居中显示line-height设置文本的行高，行距&#x3D;行高-文本&#x2F;2，可以用来设置居中\n直接子代选择器&lt;div class=&quot;home&quot;&gt;  &lt;span    &gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium    repellat quasi cumque, odit accusamus voluptates velit laudantium    facere, ratione a, molestias impedit deserunt ipsum delectus unde maxime    officia minus dolores.&lt;/span  &gt;  &lt;div class=&quot;box&quot;&gt;&lt;span&gt;草&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\n\n.home &gt; span &#123;  color: red;  padding: 20px;  margin: 20px;&#125;\n\n\n\n\n只选中了直接相连的span，如果删除&gt;换成空格则为后代选择器，两者都能选中\n选择器权重\nblock-inline\nblock块级元素可以设置宽高、inline行内级不行，宽高取决于内容的大小，但是行内替换元素可以设置，例如&#x3D;&#x3D;img&#x3D;&#x3D;、&#x3D;&#x3D;input&#x3D;&#x3D;。\n\n&#x3D;&#x3D;inline-block&#x3D;&#x3D;有两者的特性，既不占一行，又能设置宽高\n\n\n隐藏html元素的四种方法\nborder-box\nborder-box tells the browser to account for any border and padding in the values you specify for an element’s width and height. If you set an element’s width to 100 pixels, that 100 pixels will include any border or padding you added, and the content box will shrink to absorb that extra width. This typically makes it much easier to size elements. box-sizing: border-box is the default styling that browsers use for the &lt;table&gt;, &lt;select&gt;, and &lt;button&gt; elements, and for &lt;input&gt; elements whose type is radio, checkbox, reset, button, submit, color, or search.\nborder-box 告诉浏览器在您为元素的宽度和高度指定的值中考虑任何边框和填充。如果将元素的宽度设置为 100 像素，则该 100 像素将包含您添加的任何边框或填充，并且内容框将收缩以吸收该额外宽度。这通常使调整元素大小变得更加容易。box-sizing：border-box 是浏览器用于 &lt;table&gt;、&lt;select&gt; 和 &lt;button&gt; 元素的默认样式，以及类型为 radio、checkbox、reset、button、submit、color 或 search 的 &lt;input&gt; 元素的默认样式。\n\n也就是设置后元素的宽高度包括了padding和border\nmargin-top&#x2F;bottom的父元素传递\nmargin的折叠问题\n多行文字省略\n背景图适应和居中background-position:center\n\nbackground-image和img标签\n表格边框的折叠border collapse","categories":["八股面经"],"tags":["前端","HTML"]},{"title":"Rust笔记","url":"/2024/09/29/Rust%20Enum%E7%B1%BB%E5%9E%8B/","content":"  enum Message &#123;// TODO: implement the message variant types based on their usage belowChangeColor(u8,u8,u8),Echo(String),Move(Point),Quit&#125;  struct Point &#123;x: u8,y: u8,&#125;  struct State &#123;color: (u8, u8, u8),position: Point,quit: bool,message: String&#125;  impl State &#123;fn change_color(&amp;mut self, color: (u8, u8, u8)) &#123;self.color = color;&#125;  fn quit(&amp;mut self) &#123;self.quit = true;&#125;  fn echo(&amp;mut self, s: String) &#123; self.message = s &#125;  fn move_position(&amp;mut self, p: Point) &#123;self.position = p;&#125;  fn process(&amp;mut self, message: Message) &#123;// TODO: create a match expression to process the different message// variants// Remember: When passing a tuple as a function argument, you&#x27;ll need// extra parentheses: fn function((t, u, p, l, e))match message&#123;Message::ChangeColor(red,green,blue)=&gt;&#123;self.change_color((red,green,blue))&#125;,Message::Move(state)=&gt;&#123;self.move_position(state)&#125;,Message::Echo(s)=&gt;&#123;self.echo(s)&#125;Message::Quit=&gt;&#123;self.quit()&#125;  &#125;&#125;&#125;  #[cfg(test)]mod tests &#123;use super::*;  #[test]fn test_match_message_call() &#123;let mut state = State &#123;quit: false,position: Point &#123; x: 0, y: 0 &#125;,color: (0, 0, 0),message: &quot;hello world&quot;.to_string(),&#125;;state.process(Message::ChangeColor(255, 0, 255));state.process(Message::Echo(String::from(&quot;hello world&quot;)));state.process(Message::Move(Point &#123; x: 10, y: 15 &#125;));state.process(Message::Quit);  assert_eq!(state.color, (255, 0, 255));assert_eq!(state.position.x, 10);assert_eq!(state.position.y, 15);assert_eq!(state.quit, true);assert_eq!(state.message, &quot;hello world&quot;);&#125;&#125;","categories":["随笔浅记"],"tags":["Rust"]},{"title":"bomblab小记","url":"/2024/06/20/bomblab%E5%B0%8F%E8%AE%B0/","content":"被期末考硬控了很久，终于稍微有点空了，打算先试着把CSAPP写完。虽然写得很混子，但是暂时先记着，总比没有来得好。\n版本：XieGuochao&#x2F;csapp: The docker source and materials for CS:APP labs (github.com)\nPhase4这里充当笔记记录一下phase4的分析过程，phase1-3比较简单，之后也许会补上，也许不会。\n以下是对phase4汇编代码的一些注释，本来写了一大段结果忘记保存，破防之后决定参考一下别人的博客好了。\nDump of assembler code for function phase_4:=&gt; 0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp//栈空间扩展24   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx//第二个参数   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx//第一个参数   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi//   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;//参数数量不等于2，爆炸   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;//param1小于等于14，否则爆炸   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi//为func4准备参数（d1,0,14）   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax//测试返回值是否为0   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)//d2为0   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp   0x0000000000401061 &lt;+85&gt;:    retq   \n\nDump of assembler code for function func4://edi=x,esi=y,edx=14=&gt; 0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax //eax=14   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax //14-0   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx //ecx=14   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx//14逻辑右移31位（为0）   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax//14+0   0x0000000000400fdd &lt;+15&gt;:    sar    %eax//14/2（算术右移一位）   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx//???   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx    0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;//x&lt;=7则跳转至+43，否则进入递归   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;//大于等于7则函数返回0   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp   0x000000000040100b &lt;+61&gt;:    retq   \n\nPhase5Dump of assembler code for function phase_5:=&gt; 0x0000000000401062 &lt;+0&gt;:     push   %rbx   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx   0x00000000004010f3 &lt;+145&gt;:   retq   End of assembler dump.\n\nPhase6Dump of assembler code for function phase_6:   0x00000000004010f4 &lt;+0&gt;:     push   %r14   0x00000000004010f6 &lt;+2&gt;:     push   %r13   0x00000000004010f8 &lt;+4&gt;:     push   %r12   0x00000000004010fa &lt;+6&gt;:     push   %rbp   0x00000000004010fb &lt;+7&gt;:     push   %rbx   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp//r14   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13    0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14 //rsp-&gt;r14   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d //r12d-&gt;0    0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp //r13-&gt;rbp   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax//eax&lt;5 //参数小于6   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d //r12d=1//循环开始   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d//大循环 循环六次   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx //ebx=1   ; 0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax //rax=1 //循环开始   ; 0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax //换下一个参数   ; 0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)   ; 0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;   ; 0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;   ; 0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx//ebx+=1   ; 0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx   ; 0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;//小循环 循环五次 比较每个数是否相等   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax//r14-&gt;rax   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx//7-a[i]   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax//下一个参数   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax //rsi=?   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;//循环结束   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax//rdx+16取出链表下一个数的地址   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)//   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;//旧的大于新的   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp   0x00000000004011fb &lt;+263&gt;:   pop    %rbx   0x00000000004011fc &lt;+264&gt;:   pop    %rbp   0x00000000004011fd &lt;+265&gt;:   pop    %r12   0x00000000004011ff &lt;+267&gt;:   pop    %r13   0x0000000000401201 &lt;+269&gt;:   pop    %r14   0x0000000000401203 &lt;+271&gt;:   retq   ","categories":["随笔浅记"],"tags":["CSAPP"]},{"title":"Hello World","url":"/2024/09/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"x86笔记","url":"/2024/06/21/x86%E7%AC%94%E8%AE%B0/","content":"对X86寄存器、概念和常见指令做一个笔记。\n笔记来源自各大网站、博客。\n常见寄存器作用：x86-64 架构的寄存器有一些使用习惯，比如：\n\n用来传参数的寄存器：%rdi, %rsi, %rdx, %rcx, %r8, %r9\n\n保存返回值的寄存器：%rax\n\n被调用者保存状态：%rbx, %r12, %r13, %r14, %rbp, %rsp\n\n调用者保存状态：%rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11\n\n栈指针：%rsp\n\n指令指针：%rip\n\n\n函数调用约定：\n%rdi：第一个参数\n\n%rsi：第二个参数\n\n%rdx：第三个参数\n\n%rcx：第四个参数\n\n%r8：第五个参数\n\n%r9：第六个参数\n\n%rax：返回值\n\n\n数据传输指令：源目的地址:立即数,寄存器,存储器\n目的地址:寄存器,存储器\n(存储器不能到存储器)\nmov指令的五种形式：\nmovl 传送双字\nmovb 传送一个字节\nmovw 传送两个字节\n这里注意:\n&#x3D;&#x3D;movsbl&#x3D;&#x3D; &#x3D;&#x3D;movzbl&#x3D;&#x3D;指令负责拷贝一个字节,并设置目的操作数其余的位\n区别在于:\nmovsbl源操作数是单字节,move后将24位设置为源字节的最高位（在下列例子中为F）,然后拷贝到32位中。\nmovzbl 源操作数单字节,前面加24个0扩展到32位.然后拷贝到32位中.\nmov movsbl movzbl区别:\n//假设 %dh =8D,%eax=98765432 movb %dh %al      %eax=9876548D                              movsbl %dh %eax   %eax=FFFFFF8D movzbl %dh %eax   %eax=0000008D\n\n调用者保存与被调用者保存栈帧  \n想要了解栈帧的结构？我们还是先来回顾（review）以下有哪些和函数栈相关的寄存器吧。（这儿并没有包含浮点寄存器）  \n\n\n所谓调用者保存，就是可以让被调用者（自身不作为另一个调用者）随意使用，也是为了自己用到的数据不被覆盖。\n\n所谓被调用者保存，恰恰与调用者保存相反。\n\n函数调用一般参数传递（非浮点）前6个参数存于寄存器，剩下的参数按照函数定义从右向左压栈。\n\n栈指针指向函数栈栈顶。\n\n%rax 用于保存函数调用返回值。  \n  了解了这些寄存器，我们再来看看栈帧的结构\n\n\n\n就拿函数P的栈帧来说，从栈底到栈顶的方向分别存储以下内容：\n\n被保存的寄存器\n\n局部变量（sub $0x18,%rsp ）\n\n如果调用其他函数参数多于6，便有参数构造区\n\n调用其他函数时需要将返回地址压栈\n\n\n","categories":["随笔浅记"],"tags":["low-level","asm"]},{"title":"关于并行计算的路线","url":"/2024/10/02/%E5%85%B3%E4%BA%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E8%B7%AF%E7%BA%BF/","content":""},{"title":"写在之前","url":"/2024/09/29/%E5%86%99%E5%9C%A8%E4%B9%8B%E5%89%8D/","content":"一个学期文章没写多少，博客倒是换了五六次。这次大概不会再换了，大概。\n","categories":["随笔浅记"],"tags":["生活"]},{"title":"域名上踩的一个小坑","url":"/2024/06/23/%E5%9F%9F%E5%90%8D%E4%B8%8A%E8%B8%A9%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/","content":"经过将近半个月的折腾，总算在halo上安定下来。然而域名解析上却频频出事。\nIP解析正常，但是域名必须加上端口才能访问。\n经过一系列排查：vps防火墙、nginx配置、各种CDN开开关关都试了一遍。依然没找到问题所在。最后经过群里讨论确定问题出在没有走nginx的代理。\n折腾好久之后终于发现——原来是系统内部的防火墙没有开放80&#x2F;443端口，而我只检查了VPS提供商的外部防火墙。\n虽然最后解决了，但隐隐约约还是有点不爽。大抵是因为问的问题又被人看不上了吧。我尽我所能排查总结，却还是不出意外地受到了轻蔑和指指点点。\n這就是為什麼我討厭互聯網，大專水平提问题非常轻易地就会被look down upon，即使我已经尽我所能地去排查问题和总结情况。\n可是我能怎麼辦呢，要不下次說我是學藥學的吧？\n","categories":["随笔浅记"],"tags":["前端"]},{"title":"如何跳转到页面某个位置","url":"/2024/05/24/%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BD%AC%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE/","content":"如何跳转到页面某个位置\n\ngetBoundingClientRect() 是 JavaScript 中的一个非常有用的方法，它属于 Element 对象。这个方法返回一个 DOMRect 对象，该对象包含了元素的大小及其相对于视口（viewport）的位置。DOMRect 对象包含了一组只读属性：top、right、bottom、left、width 和 height，这些属性描述了元素的边界框。\n注意我们获取到的是相对值，元素滚动后视口与元素之间的距离发生改变会导致功能不好使，必须加上一个window.pageYOffset 。\n这是一个比较现代的方法。\n","categories":["随笔浅记"],"tags":["前端"]},{"title":"微训领航一面面经","url":"/2024/07/27/%E5%BE%AE%E8%AE%AD%E9%A2%86%E8%88%AA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/","content":"前30min\n自我介绍\n\n如何学习前端\n\n项目介绍\n\n\n八股吟唱\nvar let const 区别\n\nfor in for of区别\n\n原型和原型链\n\n闭包\n\n箭头函数\n\n跨域\n\n基本数据类型和引用类型\n\nsplice和slice\n\n知道promise吗\n\n垂直水平居中的方法\n\n宏任务与微任务\n\n知道Set吗\n\n输入域名到进入网页中间经历了什么\n\nDNS解析\n\n从服务器获取静态资源\n\nHTML和CSS渲染\n\n\n\nreact的hook你知道几个\n\n\n场景题和算法\n看代码说输出\n\nconsole.log(&quot;Start&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;Timeout&quot;);&#125;, 0);Promise.resolve().then(() =&gt; &#123;    console.log(&quot;Promise&quot;);&#125;);console.log(&quot;End&quot;);\n\nfunction MyComponent() &#123;    const [count, setCount] = useState(0);    useEffect(() =&gt; &#123;        console.log(&#x27;useEffect&#x27;);        return () =&gt; &#123;            console.log(&#x27;Cleanup&#x27;);        &#125;;    &#125;, []);    useEffect(() =&gt; &#123;        console.log(&#x27;count refresh&#x27;);    &#125;, [count]);    console.log(&#x27;Function body&#x27;);    return (        &lt;div&gt;            &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;        &lt;/div&gt;    );&#125;\n\n\n实现一个穿梭表 https://ant.design/components/transfer-cn\n\n算术表达式二叉树\n\n\ninterface RootNode &#123;    type: &quot;operator&quot; | &quot;number&quot;;    operator?: &quot;+&quot; | &quot;-&quot;    value?: number    // 如果是操作符，那么一定有左右子节点    left?: RootNode    right?: RootNode&#125;// 1 + 1 + 1const root: RootNode = &#123;    type: &quot;operator&quot;,    operator: &quot;+&quot;,    left: &#123;        type: &quot;number&quot;,        value: 1,    &#125;,    right: &#123;        type: &quot;operator&quot;,        operator: &quot;+&quot;,        left: &#123;            type: &quot;number&quot;,            value: 1        &#125;,        right: &#123;            type: &quot;number&quot;,            value: 1        &#125;    &#125;&#125;// 实现算法计算一个表达式树的值function evaluate(root: RootNode): number &#123;    &#125;// 将一个表达式树转换为表达式字符串function toExpression(root: RootNode): string &#123;    &#125;\n\n反问\n有什么建议吗？“回去多学学数据结构和算法再来吧”\n\n","categories":["八股面经"],"tags":["面经"]},{"title":"氓","url":"/2024/09/29/%E6%B0%93/","content":"氓之蚩蚩，抱布贸丝。匪来贸丝，来即我谋。送子涉淇，至于顿丘。匪我愆期，子无良媒。将子无怒，秋以为期。乘彼垝垣，以望复关。不见复关，泣涕涟涟。既见复关，载笑载言。尔卜尔筮，体无咎言。以尔车来，以我贿迁。桑之未落，其叶沃若。于嗟鸠兮，无食桑葚！于嗟女兮，无与士耽！士之耽兮，犹可说也。女之耽兮，不可说也。桑之落矣，其黄而陨。自我徂尔，三岁食贫。淇水汤汤，渐车帷裳。女也不爽，士贰其行。士也罔极，二三其德。三岁为妇，靡室劳矣。夙兴夜寐，靡有朝矣。言既遂矣，至于暴矣。兄弟不知，咥其笑矣。静言思之，躬自悼矣。及尔偕老，老使我怨。淇则有岸，隰则有泮。总角之宴，言笑晏晏。信誓旦旦，不思其反。反是不思，亦已焉哉！\n","categories":["生活杂谈"],"tags":["古诗文"]},{"title":"深夜的浅色床单与指尖流沙","url":"/2024/06/16/%E6%B7%B1%E5%A4%9C%E7%9A%84%E6%B5%85%E8%89%B2%E5%BA%8A%E5%8D%95%E4%B8%8E%E6%8C%87%E5%B0%96%E6%B5%81%E6%B2%99/","content":"\n      \n        0eb56511a14fa64cb38a233854ef75d8d4e2a958642e95650844f9ec18551c3941d074c43f70decee2b0f7111cdcd4ca66671dd9d2420f29c83d3c6c9497c6011425ab73615f20a18445e1057b85122f6424d87e3c52f85ce3e44d8fd9a85dc988a97562099c4519a9075fa9232583d9627de5b1aaf849df4c678d30558b613265e5937d400565a4fc478aea452f63bebd825ff7cd668d48b6e8ab7f2e888bfc6b89337b60c9514611be883ef1382944ea4560f7b0bb48980aca7875f1510ff9be8d528f55f7a769a67052932e3314df91fb7af17225496b11421703039d4749c0809158ddadeeba4e119a5fb0ed2aa8f55ccf1a57002bdc4ea77721f83084c48a0390f6172d73276b28d60b30e77170b7b1535a72c79140a53c4d63d204121cb86cdf5fd99877854aeb702c7f1495278425a895bf31d74299951b4553692841dcceef021752f978c9341dbcc713b5e82fe5174a770166cad59f46d6ad49d0841925e1090ef534c1438ebe3f1e506a1109735271a5524b5106544bcf6d3ec2671364959644c4733c5303df7cb2e3dc021487d238d1b28e44b5ae8d86effdb32908eb650e93e9f567e28b2b15121080cdbdb4201a88935889e266d77e5a3f8e02f20b6fcf533a147a5b724bbf98a9f2d5893340bc3d5b78e9444f27e8297ce32c9f280986ebf5e2e7832ff361fe4bde5811b856c3a698bc3a8ca5bd35772f51994f07a0d7daad58d677ea4a69d66bd3fe4e049814f4d03d6b2cd40703717fb91e4cbec692744ee69294a6fc6ee8eacd7103b3fe1dfd908242f925cb8fd61872548255d39c5c3e0cb7f57b053f03eadd6c5ae27649ce3869c6c01c7b6d660174044733a6fbefc5b7beaf4b9ba3dbcc3f4aebd572732963bbc56f51f7c366d0882930167718c382fed7442c04d2f2ac914cfd3b60d0e3c03e96172946f5398d4eeef197e4680b7f345b9aad47b475da31360a611aa0f5435a4d5119159f8b8f0cf89366dd15bc586f832cb4d74e5f83a2a5661ed722129445f0cb356135a91b0cbf8c8a4a8e05c60348c9f6c47ebbd26de9fbf2914de904d7f84c9b7acab32316cdf6316b64cce11a8c8017a6800c57ebbe8e86201b63b8fd2ef3eae9597cf1cd8462d2e5d842a4e576d5957b43e4c1a0157a7038c78919f8ae56cbd59a52093e1edee0c8e3edb60bd5fd65a65275042e89b54b667a444ad6ec383a27d06893e467ee81820b4c827f94bd527edfcbe6a0804a796b4b3875b8ff47aec3bc70588912b50aac8861e53812ae6db1dda77c1e2ae866f4c60a8f49112a9152f7725833228f3b61105c199a7a5ff4014252dbeec533ea3e3eae3810d634d1a857c9ebe671769e9ec54331e6ca8037099a4df5fb1b015bef200114646350d2a4e33f9298820a0979e3f23640fa24e86adc13be1bab91cd8fef4dbf6e36a7c869ea29b2ba7b29b031e195e363b5e7b83bbb81f8540efbbee77817ad3422025f7e4526ced14e3f52e385c8bdbf87636f6c09657c48f2ba306677bfe6a8d3d04d6f347f409ca9ee280e6c002e549ad0511661965444b0832b2d18b1bc73e3c98b90712105ea2bd21f959df53ecb91f7631e7f3edfc8515f5c37de7e4c6b81b68b7c4b71b0fe99de096ed7f04bb8d7b42a65a9de19abc736e537658853b8207d20ce3c349fce862fbea9f3d51e54479bc96982c5b60efd3d538f848130a4cc524cb033d9ea3a0e1af93175b8885ecb6900b8b211f50e3f284979fdadf816c62624cbb9bad28b45821768fcdf2d905a885573001e9a48b0a234f19b6da045686cdd30ad9c5278451f3a6d3acd32f721d89e36dd6b2341f4e617cfc0e6a67c5f5d14a007d255809eafc2f8c7cc34acf0dc3c777351726d0e630901dfb78e86a0587fb47e76e8cb81bcf5546bee0ce321a5acf1969ca39f022dd5dd28f54ed6d0d7ee4bab439f3e9c7ebda9567f794cf7501cf1e3bd00ce8edea1c6878bcc3ea459444f4f3829092b6926d2abbfdc7e4e1b9f3467b429e9712040b4f4ac4a49f6d3f74e7d42f3d10968a1fe6fa0366a66540c93804f1107dc1e4842d33108dce8783165a5d297666d40adaac3163fc3531db3169203e7275db4a27ab0dc0b2ec6a7d0a6dcb30224a46fe6b7c5ff4a168f5f53e66ef2b7a01da1debf41bfb753ba3449b216ef048678ceb7661ef65306924bd6e70ba23b539bd5e361c7f158b0eac9e47c153c9f944dbdecb1df14afd3190d4fd8d21dbae97206a734054282d0a11397c34c03950958a5f8dd3ec04f8f5edf32bb53a1e0ad2e02a4f6eabf6be815e848aaa180c1ec83c19c8fee630ba2f0ec73db809704dc00b3d0c30c51cf7992cda4e367da40e227813168a56594ce663eb07f082f37e2214f86da828a2199e68f7fd80c975c2e7b20e6c665e4d070309bc69759b24e8d1347466dc7ba9890db1a37de8bce2d41e86fbbd3e9331357e112f58231f3ab132d3e44eb4a5011d83d9ccbc8991ae95d4ecc3d93ca785c18d4cb5d1c66d2fb2ee943291d9aff861f0c1a531419cfd164724169d6df69eafb19f20ecc272e01710f73182a1f51091d0151625fd1c870bbf7f37ff2b70b2e049af0508c17a9c3106af36dc41c12a76ae314f923e9074a30fd6b37b042bdc3c0a771b3fb778bf5444c6efee053a6b2a290e6dbc541080421b7ecff1c0715dd04d4de187fe5fb48ebd31a4d79fc69419e75d9f38ea5e45ffcc83b550be7301b0473a72772eb20ed03ae6d014ea858e260d3aa785513269775bfff704b2b58c31ac407f2155b069495d7624cbcf68682b334efe29ac06a8b7efad377539e05c779a1a732a9f525cb81db\n      \n      \n        \n          \n          \n            未来机关授权密钥\n          \n        \n        \n      \n    \n    ","categories":["生活杂谈"],"tags":["生活","思考"]},{"title":"由61C P1开始的指针笔记","url":"/2024/07/15/%E7%94%B161C%20P1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/","content":"写61C P1的时候写出来这么一段代码\ntypedef struct Color &#123;\tuint8_t R;\tuint8_t G;\tuint8_t B;&#125; Color;typedef struct Image&#123;\tColor **image;\tuint32_t rows;\tuint32_t cols;&#125; Image;int count = image-&gt;cols*image-&gt;rows;image-&gt;image = (Color**)malloc(sizeof(Color*) * count);Color *evaluateOneCell(Image *image, int row, int col, uint32_t rule)&#123;\t// YOUR CODE HERE\tfor(int i = 0; i &lt; 6; i++)&#123;\t\tColor *pp =*(image-&gt;image+i);\t\tprintf(&quot;%3hhu %3hhu %3hhu&quot;,pp-&gt;R,pp-&gt;G,pp-&gt;B);\t&#125;&#125;\n\n我的问题在于不能理解\nColor *pp =*(image-&gt;image+i);\n\n这段代码表达的是什么？\n我的基础很差，很多代码细节都是仰仗PKU大佬来进行“学术不端”。但是之后还要继续挑战S081和ysyx,所以我必须要弄懂这些。\n以下内容多数来自C Pointers。\n首先我们知道，数组在内存中是连续存储的，而指针归根到底是指向地址的变量。\n指针的使用一个简单的例子int var = 10;int * ptr;ptr = &amp;var;\n\n指针解引用\n指针解引用是访问\nre pointer variable    int* ptr;    // note that data type of ptr and var must be same    ptr = &amp;var;    // assign the address of a variable to a pointer    printf(&quot;Value at ptr = %p \\n&quot;, ptr);    printf(&quot;Value at var = %d \\n&quot;, var);    printf(&quot;Value at *ptr = %d \\n&quot;, *ptr);&#125;// Driver programint main()&#123;    geeks();    return 0;&#125;\n\n输出\nValue at ptr = 0x7ffca84068dc Value at var = 10 Value at *ptr = 10 \n\n双指针在C语言中，我们可以创建指向指针的指针，以下是对原文的翻译。\n\n*pointer_name; // get the address stored in the inner level pointer获取内部指针储存的地址**pointer_name; // get the value pointed by inner level pointer获取内部指针地址\n\n\nNote: In C, we can create multi-level pointers with any number of levels such as – ***ptr3, ****ptr4, ******ptr5 and so on.\n\n\n最后写一下开头问题的答案吧这行代码Color *p =*(image-&gt;image + (newrow * image-&gt;cols + newcol));尝试做的是：\n\n计算newrow * image-&gt;cols + newcol，这给出了从图像开始到指定行和列的偏移量（假设图像数据是连续的，并且按行优先顺序排列）。\n\nimage-&gt;image + ...将image-&gt;image指针向前移动这个偏移量的位置。\n\n然后，*(...)试图解引用这个新的指针位置，但由于image-&gt;image很可能是一个指向Color类型（或类似类型，表示颜色的结构体）的指针，这里的解引用并不直接指向Color类型的值，而是指向了包含Color类型值的数组的一个Color元素。因此，理论上，直接解引用后赋值给Color*类型的指针p是合理的，但写法上有些绕。\n\n\n以上摘抄自文心一言，我个人的理解是*(...) 的括号里实际上是指向了一长串指针数组里的第一个数组索引的地址，因此当我们解引用时，我们实际得到了数组索引指向的地址，也就是元素本身的地址，最后再用Color*储存起来。\n以上就是这篇博文的大概内容了，我想再多写一些，可惜现在太晚了熬不住了，知识储备也不够，希望能在学习一些ysyx之后再来补充吧！\n其实有点伤心的，作为一个学习者，我追求的并不只是勉强看懂，而是能在需要的时候信手拈来。然而这么久我却依然没法好好的写完一个正式的project，感受coding的魅力。\n","categories":["随笔浅记"],"tags":["CS61C","指针"]}]